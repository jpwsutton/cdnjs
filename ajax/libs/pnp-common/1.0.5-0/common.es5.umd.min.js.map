{"version":3,"sources":["../../../../packages/common/src/util.ts","../../../../packages/common/src/netutil.ts","../../../../packages/common/src/adalclient.ts","../../../../packages/common/src/blobutil.ts","../../../../packages/common/src/collections.ts","../../../../packages/common/src/exceptions.ts","../../../../packages/common/src/libconfig.ts","../../../../packages/common/src/storage.ts","../../../../packages/common/src/decorators.ts"],"names":["getCtxCallback","context","method","params","_i","arguments","length","apply","dateAdd","date","interval","units","ret","Date","toLowerCase","setFullYear","getFullYear","setMonth","getMonth","setDate","getDate","setTime","getTime","undefined","combinePaths","paths","filter","path","stringIsNullOrEmpty","map","replace","join","getRandomString","chars","text","Array","possible","i","charAt","Math","floor","random","getGUID","d","c","r","toString","isFunc","cf","objectDefinedNotNull","obj","isArray","array","constructor","extend","target","source","noOverwrite","check","o","Object","getOwnPropertyNames","v","reduce","t","isUrlAbsolute","url","test","s","Util","Request","headers","forEach","value","name","append","FetchClient","prototype","fetch","options","global","BearerTokenFetchClient","_super","_token","_this","call","this","tslib_1.__extends","defineProperty","token","Headers","mergeHeaders","set","AdalClient","clientId","tenant","redirectUri","fromSPFxContext","spfxContext","cliendId","pageContext","aadInfo","tenantId","window","location","origin","Error","getToken","getResource","then","resource","Promise","resolve","reject","ensureAuthContext","_","login","_authContext","acquireToken","message","catch","adal.inject","displayCall","_displayCallback","navigateToLoginRequestUrl","_loginPromise","getCachedUser","popupWindow","open","focus","pollTimer","setInterval","closed","clearInterval","document","URL","indexOf","handleWindowCallback","hash","close","e","_loginInProgress","parser","createElement","href","protocol","hostname","readBlobAs","blob","mode","reader","FileReader","onload","result","readAsText","readAsArrayBuffer","Dictionary","keys","values","get","key","index","add","remove","push","merge","sourceAsDictionary_1","getKeys","sourceAsHash","hasOwnProperty","val","splice","getValues","clear","UrlException","msg","Logger","log","data","level","RuntimeConfigImpl","_v","config","RuntimeConfig","PnPClientStorageWrapper","store","defaultTimeoutMinutes","enabled","enableCacheExpiration","write","cacheExpirationHandler","getItem","persistable","JSON","parse","expiration","delete","put","expire","setItem","createPersistable","removeItem","getOrPut","getter","deleteExpired","str","defaultTimeout","defaultCachingTimeoutSeconds","stringify","pnp","setTimeout","cacheExpirationIntervalMilliseconds","MemoryStorage","_store","count","PnPClientStorage","_local","_session","localStorage","sessionStorage","deprecationVersion","propertyKey","descriptor","args"],"mappings":"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","sourcesContent":["/**\n * Gets a callback function which will maintain context across async calls.\n * Allows for the calling pattern getCtxCallback(thisobj, method, methodarg1, methodarg2, ...)\n *\n * @param context The object that will be the 'this' value in the callback\n * @param method The method to which we will apply the context and parameters\n * @param params Optional, additional arguments to supply to the wrapped method when it is invoked\n */\nexport function getCtxCallback(context: any, method: Function, ...params: any[]): Function {\n    return function () {\n        method.apply(context, params);\n    };\n}\n\n/**\n * Adds a value to a date\n *\n * @param date The date to which we will add units, done in local time\n * @param interval The name of the interval to add, one of: ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second']\n * @param units The amount to add to date of the given interval\n *\n * http://stackoverflow.com/questions/1197928/how-to-add-30-minutes-to-a-javascript-date-object\n */\nexport function dateAdd(date: Date, interval: string, units: number): Date | undefined {\n    let ret: Date | undefined = new Date(date); // don't change original date\n    switch (interval.toLowerCase()) {\n        case \"year\": ret.setFullYear(ret.getFullYear() + units); break;\n        case \"quarter\": ret.setMonth(ret.getMonth() + 3 * units); break;\n        case \"month\": ret.setMonth(ret.getMonth() + units); break;\n        case \"week\": ret.setDate(ret.getDate() + 7 * units); break;\n        case \"day\": ret.setDate(ret.getDate() + units); break;\n        case \"hour\": ret.setTime(ret.getTime() + units * 3600000); break;\n        case \"minute\": ret.setTime(ret.getTime() + units * 60000); break;\n        case \"second\": ret.setTime(ret.getTime() + units * 1000); break;\n        default: ret = undefined; break;\n    }\n    return ret;\n}\n\n/**\n * Combines an arbitrary set of paths ensuring and normalizes the slashes\n *\n * @param paths 0 to n path parts to combine\n */\nexport function combinePaths(...paths: string[]): string {\n\n    return paths\n        .filter(path => !stringIsNullOrEmpty(path))\n        .map(path => path.replace(/^[\\\\|\\/]/, \"\").replace(/[\\\\|\\/]$/, \"\"))\n        .join(\"/\")\n        .replace(/\\\\/g, \"/\");\n}\n\n/**\n * Gets a random string of chars length\n * \n * https://stackoverflow.com/questions/1349404/generate-random-string-characters-in-javascript\n *\n * @param chars The length of the random string to generate\n */\nexport function getRandomString(chars: number): string {\n    const text = new Array(chars);\n    const possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    for (let i = 0; i < chars; i++) {\n        text[i] = possible.charAt(Math.floor(Math.random() * possible.length));\n    }\n    return text.join(\"\");\n}\n\n/**\n * Gets a random GUID value\n *\n * http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript\n */\n/* tslint:disable no-bitwise */\nexport function getGUID(): string {\n    let d = new Date().getTime();\n    const guid = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n        const r = (d + Math.random() * 16) % 16 | 0;\n        d = Math.floor(d / 16);\n        return (c === \"x\" ? r : (r & 0x3 | 0x8)).toString(16);\n    });\n    return guid;\n}\n/* tslint:enable */\n\n/**\n * Determines if a given value is a function\n *\n * @param cf The thing to test for functionness\n */\nexport function isFunc(cf: any): boolean {\n    return typeof cf === \"function\";\n}\n\n/**\n * Determines if an object is both defined and not null\n * @param obj Object to test\n */\nexport function objectDefinedNotNull(obj: any): boolean {\n    return typeof obj !== \"undefined\" && obj !== null;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Array or not.\n*/\nexport function isArray(array: any): boolean {\n\n    if (Array.isArray) {\n        return Array.isArray(array);\n    }\n\n    return array && typeof array.length === \"number\" && array.constructor === Array;\n}\n\n/**\n * Provides functionality to extend the given object by doing a shallow copy\n *\n * @param target The object to which properties will be copied\n * @param source The source object from which properties will be copied\n * @param noOverwrite If true existing properties on the target are not overwritten from the source\n *\n */\nexport function extend(target: any, source: any, noOverwrite = false): any {\n\n    if (!objectDefinedNotNull(source)) {\n        return target;\n    }\n\n    // ensure we don't overwrite things we don't want overwritten\n    const check: (o: any, i: string) => Boolean = noOverwrite ? (o, i) => !(i in o) : () => true;\n\n    return Object.getOwnPropertyNames(source)\n        .filter((v: string) => check(target, v))\n        .reduce((t: any, v: string) => {\n            t[v] = source[v];\n            return t;\n        }, target);\n}\n\n/**\n * Determines if a given url is absolute\n *\n * @param url The url to check to see if it is absolute\n */\nexport function isUrlAbsolute(url: string): boolean {\n    return /^https?:\\/\\/|^\\/\\//i.test(url);\n}\n\n/**\n * Determines if a string is null or empty or undefined\n *\n * @param s The string to test\n */\nexport function stringIsNullOrEmpty(s: string): boolean {\n    return typeof s === \"undefined\" || s === null || s.length < 1;\n}\n\nexport class Util {\n\n    /**\n     * Gets a callback function which will maintain context across async calls.\n     * Allows for the calling pattern getCtxCallback(thisobj, method, methodarg1, methodarg2, ...)\n     *\n     * @param context The object that will be the 'this' value in the callback\n     * @param method The method to which we will apply the context and parameters\n     * @param params Optional, additional arguments to supply to the wrapped method when it is invoked\n     */\n    public static getCtxCallback = getCtxCallback;\n\n\n    /**\n     * Adds a value to a date\n     *\n     * @param date The date to which we will add units, done in local time\n     * @param interval The name of the interval to add, one of: ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second']\n     * @param units The amount to add to date of the given interval\n     *\n     * http://stackoverflow.com/questions/1197928/how-to-add-30-minutes-to-a-javascript-date-object\n     */\n    public static dateAdd = dateAdd;\n\n    /**\n     * Combines an arbitrary set of paths ensuring and normalizes the slashes\n     *\n     * @param paths 0 to n path parts to combine\n     */\n    public static combinePaths = combinePaths;\n\n    /**\n     * Gets a random string of chars length\n     *\n     * @param chars The length of the random string to generate\n     */\n    public static getRandomString = getRandomString;\n\n    /**\n     * Gets a random GUID value\n     *\n     * http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript\n     */\n    public static getGUID = getGUID;\n\n    /**\n     * Determines if a given value is a function\n     *\n     * @param cf The thing to test for functionness\n     */\n    public static isFunc = isFunc;\n\n    /**\n     * Determines if an object is both defined and not null\n     * @param obj Object to test\n     */\n    public static objectDefinedNotNull = objectDefinedNotNull;\n\n    /**\n     * @returns whether the provided parameter is a JavaScript Array or not.\n    */\n    public static isArray = isArray;\n\n    /**\n     * Provides functionality to extend the given object by doing a shallow copy\n     *\n     * @param target The object to which properties will be copied\n     * @param source The source object from which properties will be copied\n     * @param noOverwrite If true existing properties on the target are not overwritten from the source\n     *\n     */\n    public static extend = extend;\n\n    /**\n     * Determines if a given url is absolute\n     *\n     * @param url The url to check to see if it is absolute\n     */\n    public static isUrlAbsolute = isUrlAbsolute;\n\n    /**\n     * Determines if a string is null or empty or undefined\n     *\n     * @param s The string to test\n     */\n    public static stringIsNullOrEmpty = stringIsNullOrEmpty;\n}\n","import { extend, objectDefinedNotNull } from \"./util\";\n\ndeclare var global: { fetch(url: string, options: any): Promise<Response> };\n\nexport interface ConfigOptions {\n    headers?: string[][] | { [key: string]: string } | Headers;\n    mode?: \"navigate\" | \"same-origin\" | \"no-cors\" | \"cors\";\n    credentials?: \"omit\" | \"same-origin\" | \"include\";\n    cache?: \"default\" | \"no-store\" | \"reload\" | \"no-cache\" | \"force-cache\" | \"only-if-cached\";\n}\n\nexport interface FetchOptions extends ConfigOptions {\n    method?: string;\n    body?: any;\n}\n\nexport interface HttpClientImpl {\n    fetch(url: string, options: FetchOptions): Promise<Response>;\n}\n\nexport interface RequestClient {\n    fetch(url: string, options?: FetchOptions): Promise<Response>;\n    fetchRaw(url: string, options?: FetchOptions): Promise<Response>;\n    get(url: string, options?: FetchOptions): Promise<Response>;\n    post(url: string, options?: FetchOptions): Promise<Response>;\n    patch(url: string, options?: FetchOptions): Promise<Response>;\n    delete(url: string, options?: FetchOptions): Promise<Response>;\n}\n\nexport function mergeHeaders(target: Headers, source: any): void {\n    if (typeof source !== \"undefined\" && source !== null) {\n        const temp = <any>new Request(\"\", { headers: source });\n        temp.headers.forEach((value: string, name: string) => {\n            target.append(name, value);\n        });\n    }\n}\n\nexport function mergeOptions(target: ConfigOptions, source: ConfigOptions): void {\n\n    if (objectDefinedNotNull(source)) {\n        const headers = extend(target.headers || {}, source.headers);\n        target = extend(target, source);\n        target.headers = headers;\n    }\n}\n\n/**\n * Makes requests using the global/window fetch API\n */\nexport class FetchClient implements HttpClientImpl {\n    public fetch(url: string, options: FetchOptions): Promise<Response> {\n        return global.fetch(url, options);\n    }\n}\n\n/**\n * Makes requests using the fetch API adding the supplied token to the Authorization header\n */\nexport class BearerTokenFetchClient extends FetchClient {\n\n    constructor(private _token: string) {\n        super();\n    }\n\n    public get token() {\n        return this._token;\n    }\n\n    public set token(token: string) {\n        this._token = token;\n    }\n\n    public fetch(url: string, options: FetchOptions = {}): Promise<Response> {\n\n        const headers = new Headers();\n\n        mergeHeaders(headers, options.headers);\n\n        headers.set(\"Authorization\", `Bearer ${this._token}`);\n\n        options.headers = headers;\n\n        return super.fetch(url, options);\n    }\n}\n","import {\n    FetchOptions,\n    BearerTokenFetchClient,\n} from \"./netutil\";\nimport { isUrlAbsolute, combinePaths } from \"./util\";\nimport { ISPFXContext } from \"./spfxContextInterface\";\nimport AuthenticationContext, * as adal from \"adal-angular\";\n\n/**\n * Azure AD Client for use in the browser\n */\nexport class AdalClient extends BearerTokenFetchClient {\n\n    /**\n     * Our auth context\n     */\n    private static _authContext: AuthenticationContext | null = null;\n\n    /**\n     * Callback used by the adal auth system\n     */\n    private _displayCallback: (url: string) => void | null;\n\n    /**\n     * Promise used to ensure the user is logged in\n     */\n    private _loginPromise: Promise<void> | null;\n\n    /**\n     * Creates a new instance of AdalClient\n     * @param clientId Azure App Id\n     * @param tenant Office 365 tenant (Ex: {tenant}.onmicrosoft.com)\n     * @param redirectUri The redirect url used to authenticate the \n     */\n    constructor(public clientId: string, public tenant: string, public redirectUri: string) {\n        super(null);\n    }\n\n    /**\n     * Creates a new AdalClient using the values of the supplied SPFx context\n     * \n     * @param spfxContext Current SPFx context\n     * @param clientId Optional client id to use instead of the built-in SPFx id\n     * @description Using this method and the default clientId requires that the features described in\n     * this article https://docs.microsoft.com/en-us/sharepoint/dev/spfx/use-aadhttpclient are activated in the tenant. If not you can\n     * creat your own app, grant permissions and use that clientId here along with the SPFx context\n     */\n    public static fromSPFxContext(spfxContext: ISPFXContext | any, cliendId = \"c58637bb-e2e1-4312-8a00-04b5ffcd3403\"): AdalClient {\n\n        // this \"magic\" client id is the one to which permissions are granted behind the scenes\n        // this redirectUrl is the page as used by spfx\n        return new AdalClient(cliendId, spfxContext.pageContext.aadInfo.tenantId.toString(), combinePaths(window.location.origin, \"/_forms/spfxsinglesignon.aspx\"));\n    }\n\n    /**\n     * Conducts the fetch opertation against the AAD secured resource\n     * \n     * @param url Absolute URL for the request\n     * @param options Any fetch options passed to the underlying fetch implementation\n     */\n    public fetch(url: string, options: FetchOptions): Promise<Response> {\n\n        if (!isUrlAbsolute(url)) {\n            throw new Error(\"You must supply absolute urls to AdalClient.fetch.\");\n        }\n\n        // the url we are calling is the resource\n        return this.getToken(this.getResource(url)).then(token => {\n            this.token = token;\n            return super.fetch(url, options);\n        });\n    }\n\n    /**\n     * Gets a token based on the current user\n     * \n     * @param resource The resource for which we are requesting a token\n     */\n    public getToken(resource: string): Promise<string> {\n\n        return new Promise((resolve, reject) => {\n\n            this.ensureAuthContext().then(_ => this.login()).then(_ => {\n\n                AdalClient._authContext.acquireToken(resource, (message: string, token: string) => {\n\n                    if (message) {\n                        return reject(new Error(message));\n                    }\n\n                    resolve(token);\n                });\n\n            }).catch(reject);\n        });\n    }\n\n    /**\n     * Ensures we have created and setup the adal AuthenticationContext instance\n     */\n    private ensureAuthContext(): Promise<void> {\n\n        return new Promise(resolve => {\n\n            if (AdalClient._authContext === null) {\n                AdalClient._authContext = (<any>adal).inject({\n                    clientId: this.clientId,\n                    displayCall: (url: string) => {\n                        if (this._displayCallback) {\n                            this._displayCallback(url);\n                        }\n                    },\n                    navigateToLoginRequestUrl: false,\n                    redirectUri: this.redirectUri,\n                    tenant: this.tenant,\n                });\n            }\n\n            resolve();\n        });\n    }\n\n    /**\n     * Ensures the current user is logged in\n     */\n    private login(): Promise<void> {\n\n        if (this._loginPromise) {\n            return this._loginPromise;\n        }\n\n        this._loginPromise = new Promise((resolve, reject) => {\n\n            if (AdalClient._authContext.getCachedUser()) {\n                return resolve();\n            }\n\n            this._displayCallback = (url: string) => {\n\n                const popupWindow = window.open(url, \"login\", \"width=483, height=600\");\n\n                if (!popupWindow) {\n                    return reject(new Error(\"Could not open pop-up window for auth. Likely pop-ups are blocked by the browser.\"));\n                }\n\n                if (popupWindow && popupWindow.focus) {\n                    popupWindow.focus();\n                }\n\n                const pollTimer = window.setInterval(() => {\n\n                    if (!popupWindow || popupWindow.closed || popupWindow.closed === undefined) {\n                        window.clearInterval(pollTimer);\n                    }\n\n                    try {\n                        if (popupWindow.document.URL.indexOf(this.redirectUri) !== -1) {\n                            window.clearInterval(pollTimer);\n                            AdalClient._authContext.handleWindowCallback(popupWindow.location.hash);\n                            popupWindow.close();\n                            resolve();\n                        }\n                    } catch (e) {\n                        reject(e);\n                    }\n                }, 30);\n            };\n\n            // this triggers the login process\n            this.ensureAuthContext().then(_ => {\n                (<any>AdalClient._authContext)._loginInProgress = false;\n                AdalClient._authContext.login();\n                this._displayCallback = null;\n            });\n        });\n\n        return this._loginPromise;\n    }\n\n    /**\n     * Parses out the root of the request url to use as the resource when getting the token\n     * \n     * After: https://gist.github.com/jlong/2428561\n     * @param url The url to parse\n     */\n    private getResource(url: string): string {\n        const parser = <HTMLAnchorElement>document.createElement(\"a\");\n        parser.href = url;\n        return `${parser.protocol}//${parser.hostname}`;\n    }\n}\n","/**\n * Reads a blob as text\n *\n * @param blob The data to read\n */\nexport function readBlobAsText(blob: Blob): Promise<string> {\n    return readBlobAs<string>(blob, \"string\");\n}\n\n/**\n * Reads a blob into an array buffer\n *\n * @param blob The data to read\n */\nexport function readBlobAsArrayBuffer(blob: Blob): Promise<ArrayBuffer> {\n    return readBlobAs<ArrayBuffer>(blob, \"buffer\");\n}\n\n/**\n * Generic method to read blob's content\n *\n * @param blob The data to read\n * @param mode The read mode\n */\nfunction readBlobAs<T>(blob: Blob, mode: \"string\" | \"buffer\"): Promise<T> {\n\n    return new Promise<T>((resolve, reject) => {\n\n        try {\n\n            const reader = new FileReader();\n            reader.onload = (e: any) => {\n                resolve(e.target.result);\n            };\n\n            switch (mode) {\n                case \"string\":\n                    reader.readAsText(blob);\n                    break;\n                case \"buffer\":\n                    reader.readAsArrayBuffer(blob);\n                    break;\n            }\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n","/**\n * Interface defining an object with a known property type\n */\nexport interface TypedHash<T> {\n    [key: string]: T;\n}\n\n/**\n * Generic dictionary\n */\nexport class Dictionary<T> {\n\n    /**\n     * Creates a new instance of the Dictionary<T> class\n     *\n     * @constructor\n     */\n    constructor(private keys: string[] = [], private values: T[] = []) {\n    }\n\n    /**\n     * Gets a value from the collection using the specified key\n     *\n     * @param key The key whose value we want to return, returns null if the key does not exist\n     */\n    public get(key: string): T | null {\n        const index = this.keys.indexOf(key);\n        if (index < 0) {\n            return null;\n        }\n        return this.values[index];\n    }\n\n    /**\n     * Adds the supplied key and value to the dictionary\n     *\n     * @param key The key to add\n     * @param o The value to add\n     */\n    public add(key: string, o: T | null): void {\n        const index = this.keys.indexOf(key);\n        if (index > -1) {\n            if (o === null) {\n                this.remove(key);\n            } else {\n                this.values[index] = o;\n            }\n        } else {\n            if (o !== null) {\n                this.keys.push(key);\n                this.values.push(o);\n            }\n        }\n    }\n\n    /**\n     * Merges the supplied typed hash into this dictionary instance. Existing values are updated and new ones are created as appropriate.\n     */\n    public merge(source: TypedHash<T> | Dictionary<T>): void {\n        if (\"getKeys\" in source) {\n            const sourceAsDictionary = source as Dictionary<T>;\n            sourceAsDictionary.getKeys().map(key => {\n                this.add(key, sourceAsDictionary.get(key));\n            });\n        } else {\n            const sourceAsHash = source as TypedHash<T>;\n            for (const key in sourceAsHash) {\n                if (sourceAsHash.hasOwnProperty(key)) {\n                    this.add(key, sourceAsHash[key]);\n                }\n            }\n        }\n    }\n\n    /**\n     * Removes a value from the dictionary\n     *\n     * @param key The key of the key/value pair to remove. Returns null if the key was not found.\n     */\n    public remove(key: string): T | null {\n        const index = this.keys.indexOf(key);\n        if (index < 0) {\n            return null;\n        }\n        const val = this.values[index];\n        this.keys.splice(index, 1);\n        this.values.splice(index, 1);\n        return val;\n    }\n\n    /**\n     * Returns all the keys currently in the dictionary as an array\n     */\n    public getKeys(): string[] {\n        return this.keys;\n    }\n\n    /**\n     * Returns all the values currently in the dictionary as an array\n     */\n    public getValues(): T[] {\n        return this.values;\n    }\n\n    /**\n     * Clears the current dictionary\n     */\n    public clear(): void {\n        this.keys = [];\n        this.values = [];\n    }\n\n    /**\n     * Gets a count of the items currently in the dictionary\n     */\n    public get count(): number {\n        return this.keys.length;\n    }\n}\n","import { Logger, LogLevel } from \"@pnp/logging\";\n\nexport class UrlException extends Error {\n\n    constructor(msg: string) {\n        super(msg);\n        this.name = \"UrlException\";\n        Logger.log({ data: {}, level: LogLevel.Error, message: `[${this.name}]::${this.message}` });\n    }\n}\n","import { TypedHash, Dictionary } from \"./collections\";\nimport { ISPFXContext } from \"./spfxContextInterface\";\n\nexport interface LibraryConfiguration {\n\n    /**\n     * Allows caching to be global disabled, default: false\n     */\n    globalCacheDisable?: boolean;\n\n    /**\n     * Defines the default store used by the usingCaching method, default: session\n     */\n    defaultCachingStore?: \"session\" | \"local\";\n\n    /**\n     * Defines the default timeout in seconds used by the usingCaching method, default 30\n     */\n    defaultCachingTimeoutSeconds?: number;\n\n    /**\n     * If true a timeout expired items will be removed from the cache in intervals determined by cacheTimeoutInterval\n     */\n    enableCacheExpiration?: boolean;\n\n    /**\n     * Determines the interval in milliseconds at which the cache is checked to see if items have expired (min: 100)\n     */\n    cacheExpirationIntervalMilliseconds?: number;\n\n    /**\n     * Used to supply the current context from an SPFx webpart to the library\n     */\n    spfxContext?: any;\n}\n\nexport function setup(config: LibraryConfiguration): void {\n    RuntimeConfig.extend(config);\n}\n\nexport class RuntimeConfigImpl {\n\n    private _v: Dictionary<any>;\n\n    constructor() {\n\n        this._v = new Dictionary();\n\n        // setup defaults\n        this._v.add(\"defaultCachingStore\", \"session\");\n        this._v.add(\"defaultCachingTimeoutSeconds\", 60);\n        this._v.add(\"globalCacheDisable\", false);\n        this._v.add(\"enableCacheExpiration\", false);\n        this._v.add(\"cacheExpirationIntervalMilliseconds\", 750);\n        this._v.add(\"spfxContext\", null);\n    }\n\n    /**\n     * \n     * @param config The set of properties to add to the globa configuration instance\n     */\n    public extend(config: TypedHash<any>): void {\n\n        Object.keys(config).forEach((key: string) => {\n            this._v.add(key, config[key]);\n        });\n    }\n\n    public get(key: string): any {\n        return this._v.get(key);\n    }\n\n    public get defaultCachingStore(): \"session\" | \"local\" {\n        return this.get(\"defaultCachingStore\");\n    }\n\n    public get defaultCachingTimeoutSeconds(): number {\n        return this.get(\"defaultCachingTimeoutSeconds\");\n    }\n\n    public get globalCacheDisable(): boolean {\n        return this.get(\"globalCacheDisable\");\n    }\n\n    public get enableCacheExpiration(): boolean {\n        return this.get(\"enableCacheExpiration\");\n    }\n\n    public get cacheExpirationIntervalMilliseconds(): number {\n        return this.get(\"cacheExpirationIntervalMilliseconds\");\n    }\n\n    public get spfxContext(): ISPFXContext {\n        return this.get(\"spfxContext\");\n    }\n}\n\nconst _runtimeConfig = new RuntimeConfigImpl();\n\nexport let RuntimeConfig = _runtimeConfig;\n","import { dateAdd, getCtxCallback } from \"./util\";\nimport { Dictionary } from \"./collections\";\nimport { RuntimeConfig } from \"./libconfig\";\nimport { Logger, LogLevel } from \"@pnp/logging\";\n\n/**\n * A wrapper class to provide a consistent interface to browser based storage\n *\n */\nexport class PnPClientStorageWrapper implements PnPClientStore {\n\n    /**\n     * True if the wrapped storage is available; otherwise, false\n     */\n    public enabled: boolean;\n\n    /**\n     * Creates a new instance of the PnPClientStorageWrapper class\n     *\n     * @constructor\n     */\n    constructor(private store: Storage, public defaultTimeoutMinutes = -1) {\n        this.enabled = this.test();\n        // if the cache timeout is enabled call the handler\n        // this will clear any expired items and set the timeout function\n        if (RuntimeConfig.enableCacheExpiration) {\n            Logger.write(`Enabling cache expiration.`, LogLevel.Info);\n            this.cacheExpirationHandler();\n        }\n    }\n\n    /**\n     * Get a value from storage, or null if that value does not exist\n     *\n     * @param key The key whose value we want to retrieve\n     */\n    public get<T>(key: string): T | null {\n\n        if (!this.enabled) {\n            return null;\n        }\n\n        const o = this.store.getItem(key);\n\n        if (o == null) {\n            return null;\n        }\n\n        const persistable = JSON.parse(o);\n\n        if (new Date(persistable.expiration) <= new Date()) {\n\n            Logger.write(`Removing item with key '${key}' from cache due to expiration.`, LogLevel.Info);\n            this.delete(key);\n            return null;\n\n        } else {\n\n            return persistable.value as T;\n        }\n    }\n\n    /**\n     * Adds a value to the underlying storage\n     *\n     * @param key The key to use when storing the provided value\n     * @param o The value to store\n     * @param expire Optional, if provided the expiration of the item, otherwise the default is used\n     */\n    public put(key: string, o: any, expire?: Date): void {\n        if (this.enabled) {\n            this.store.setItem(key, this.createPersistable(o, expire));\n        }\n    }\n\n    /**\n     * Deletes a value from the underlying storage\n     *\n     * @param key The key of the pair we want to remove from storage\n     */\n    public delete(key: string): void {\n        if (this.enabled) {\n            this.store.removeItem(key);\n        }\n    }\n\n    /**\n     * Gets an item from the underlying storage, or adds it if it does not exist using the supplied getter function\n     *\n     * @param key The key to use when storing the provided value\n     * @param getter A function which will upon execution provide the desired value\n     * @param expire Optional, if provided the expiration of the item, otherwise the default is used\n     */\n    public getOrPut<T>(key: string, getter: () => Promise<T>, expire?: Date): Promise<T> {\n        if (!this.enabled) {\n            return getter();\n        }\n\n        return new Promise((resolve) => {\n\n            const o = this.get<T>(key);\n\n            if (o == null) {\n                getter().then((d) => {\n                    this.put(key, d, expire);\n                    resolve(d);\n                });\n            } else {\n                resolve(o);\n            }\n        });\n    }\n\n    /**\n     * Deletes any expired items placed in the store by the pnp library, leaves other items untouched\n     */\n    public deleteExpired(): Promise<void> {\n\n        return new Promise<void>((resolve, reject) => {\n\n            if (!this.enabled) {\n                resolve();\n            }\n\n            try {\n\n                for (let i = 0; i < this.store.length; i++) {\n                    const key = this.store.key(i);\n                    if (key !== null) {\n                        // test the stored item to see if we stored it\n                        if (/[\"|']?pnp[\"|']? ?: ?1/i.test(<string>this.store.getItem(key))) {\n                            // get those items as get will delete from cache if they are expired\n                            this.get(key);\n                        }\n                    }\n                }\n\n                resolve();\n\n            } catch (e) { reject(e); }\n        });\n    }\n\n    /**\n     * Used to determine if the wrapped storage is available currently\n     */\n    private test(): boolean {\n        const str = \"test\";\n        try {\n            this.store.setItem(str, str);\n            this.store.removeItem(str);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Creates the persistable to store\n     */\n    private createPersistable(o: any, expire?: Date): string {\n        if (typeof expire === \"undefined\") {\n\n            // ensure we are by default inline with the global library setting\n            let defaultTimeout = RuntimeConfig.defaultCachingTimeoutSeconds;\n            if (this.defaultTimeoutMinutes > 0) {\n                defaultTimeout = this.defaultTimeoutMinutes * 60;\n            }\n            expire = dateAdd(new Date(), \"second\", defaultTimeout);\n        }\n\n        return JSON.stringify({ pnp: 1, expiration: expire, value: o });\n    }\n\n    /**\n     * Deletes expired items added by this library in this.store and sets a timeout to call itself\n     */\n    private cacheExpirationHandler(): void {\n\n        Logger.write(\"Called cache expiration handler.\", LogLevel.Verbose);\n        this.deleteExpired().then(_ => {\n\n            // call ourself in the future\n            setTimeout(getCtxCallback(this, this.cacheExpirationHandler), RuntimeConfig.cacheExpirationIntervalMilliseconds);\n        }).catch(e => {\n\n            // we've got some error - so just stop the loop and report the error\n            Logger.log({\n                data: e,\n                level: LogLevel.Error,\n                message: \"Error deleting expired cache entries, see data for details. Timeout not reset.\",\n            });\n        });\n    }\n}\n\n/**\n * Interface which defines the operations provided by a client storage object\n */\nexport interface PnPClientStore {\n    /**\n     * True if the wrapped storage is available; otherwise, false\n     */\n    enabled: boolean;\n\n    /**\n     * Get a value from storage, or null if that value does not exist\n     *\n     * @param key The key whose value we want to retrieve\n     */\n    get(key: string): any;\n\n    /**\n     * Adds a value to the underlying storage\n     *\n     * @param key The key to use when storing the provided value\n     * @param o The value to store\n     * @param expire Optional, if provided the expiration of the item, otherwise the default is used\n     */\n    put(key: string, o: any, expire?: Date): void;\n\n    /**\n     * Deletes a value from the underlying storage\n     *\n     * @param key The key of the pair we want to remove from storage\n     */\n    delete(key: string): void;\n\n    /**\n     * Gets an item from the underlying storage, or adds it if it does not exist using the supplied getter function\n     *\n     * @param key The key to use when storing the provided value\n     * @param getter A function which will upon execution provide the desired value\n     * @param expire Optional, if provided the expiration of the item, otherwise the default is used\n     */\n    getOrPut<T>(key: string, getter: () => Promise<T>, expire?: Date): Promise<T>;\n\n    /**\n     * Removes any expired items placed in the store by the pnp library, leaves other items untouched\n     */\n    deleteExpired(): Promise<void>;\n}\n\n/**\n * A thin implementation of in-memory storage for use in nodejs\n */\nclass MemoryStorage {\n\n    constructor(private _store = new Dictionary<string>()) { }\n\n    public get length(): number {\n        return this._store.count;\n    }\n\n    public clear(): void {\n        this._store.clear();\n    }\n\n    public getItem(key: string): any {\n        return this._store.get(key);\n    }\n\n    public key(index: number): string {\n        return this._store.getKeys()[index];\n    }\n\n    public removeItem(key: string): void {\n        this._store.remove(key);\n    }\n\n    public setItem(key: string, data: string): void {\n        this._store.add(key, data);\n    }\n\n    [key: string]: any;\n    [index: number]: string;\n}\n\n/**\n * A class that will establish wrappers for both local and session storage\n */\nexport class PnPClientStorage {\n\n    /**\n     * Creates a new instance of the PnPClientStorage class\n     *\n     * @constructor\n     */\n    constructor(private _local: PnPClientStore | null = null, private _session: PnPClientStore | null = null) { }\n\n    /**\n     * Provides access to the local storage of the browser\n     */\n    public get local(): PnPClientStore {\n\n        if (this._local === null) {\n            this._local = typeof localStorage !== \"undefined\" ? new PnPClientStorageWrapper(localStorage) : new PnPClientStorageWrapper(new MemoryStorage());\n        }\n\n        return this._local;\n    }\n\n    /**\n     * Provides access to the session storage of the browser\n     */\n    public get session(): PnPClientStore {\n\n        if (this._session === null) {\n            this._session = typeof sessionStorage !== \"undefined\" ? new PnPClientStorageWrapper(sessionStorage) : new PnPClientStorageWrapper(new MemoryStorage());\n        }\n\n        return this._session;\n    }\n}\n","import { Logger, LogLevel } from \"@pnp/logging\";\n\nexport function deprecated(deprecationVersion: string, message: string) {\n\n    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n\n        const method = descriptor.value;\n\n        descriptor.value = function (this: any, ...args: any[]) {\n            Logger.log({\n                data: {\n                    descriptor: descriptor,\n                    propertyKey: propertyKey,\n                    target: target,\n                },\n                level: LogLevel.Warning,\n                message: `(${deprecationVersion}) ${message}`,\n            });\n\n            return method.apply(this, args);\n        };\n    };\n}\n\nexport function beta(message = \"This feature is flagged as beta and is subject to change.\") {\n\n    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n\n        const method = descriptor.value;\n\n        descriptor.value = function (this: any, ...args: any[]) {\n            Logger.log({\n                data: {\n                    descriptor: descriptor,\n                    propertyKey: propertyKey,\n                    target: target,\n                },\n                level: LogLevel.Warning,\n                message: message,\n            });\n\n            return method.apply(this, args);\n        };\n    };\n}\n"]}