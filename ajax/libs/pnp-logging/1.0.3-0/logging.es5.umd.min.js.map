{"version":3,"sources":["../../../../packages/logging/src/logger.ts","../../../../packages/logging/src/listeners.ts"],"names":["exports","module","factory","define","amd","global","pnp","logging","Logger","defineProperty","get","instance","activeLogLevel","value","enumerable","listeners","_i","arguments","length","clearSubscribers","configurable","level","log","message","writeJSON","json","JSON","stringify","entry","error","err","data","LoggerImpl","subscribers","this","prototype","subscribe","listener","push","s","write","ConsoleListener","msg","format","console","FunctionListener","method"],"mappings":";;;;;;;;;eAQA,iBAAAA,SAAA,oBAAAC,OAAAC,EAAAF,SAAA,mBAAAG,QAAAA,OAAAC,IAAAD,QAAA,WAAAD,MAkFCG,EAAAC,IAAAD,EAAAC,QAAAD,EAAAC,IAAAC,mBA3EG,SAAAP,GAAkB,mBAEjB,oBAEDQ,KA6EO,cA3ENC,eAAAD,EAAA,kBAEDE,IAAA,kBAAAF,EAAAG,SAAAC,6BAEeC,KACVF,SAAAC,eAAAC,eAEJ,2BAAAJ,eAAAD,EAAA,6GAOuBM,YAAA,gBAAA,2BAQpB,IADU,IAAAC,KACHC,EAAO,EAAAA,EAAQC,UAACC,OAAgBF,IAC1CD,EAAAC,GAAAC,UAAAD,yDAOAG,iBAAA,wDAAAV,eAAAD,EAAA,iDAQaM,YAAd,EAAqCM,cAAA,+BAUd,IAATC,IAAdA,EAAmC,GAAAb,EAAAG,SAAAW,KAAAD,MAAAA,EAAAE,QAAAA,KASrBf,EAAAgB,UAAd,SAAiCC,EAAAJ,QACtB,IAAPA,IAAoBA,EAAO,GAC9Bb,EAAAG,SAAAW,KAAAD,MAAAA,EAAAE,QAAAG,KAAAC,UAAAF,QAQGH,IAAO,SAAYM,GACtBpB,EAAAG,SAAAW,IAAAM,MAKkBC,MAAA,SAAcC,GAAuCtB,EAAAG,SAAWW,KAAXS,KAAAD,EAA+BT,MAAA,EAAAE,QAAAO,EAAAP,WAEhGf,EA/EN,KAiFA,WAEM,SAAAwB,EAAApB,EAAAqB,QACY,IAATrB,IAA6BA,EAAC,QACnB,IAAbqB,IAAwBA,MAC5BC,KAAAtB,eAASA,EACZsB,KAAAD,YAAAA,WAEDE,UAAAC,UAAA,SAAAC,QACIJ,YAAYK,KAAAD,4EAGT,OAFNH,KAAAD,YAAAf,OAAA,EAEMqB,UACH9B,eAAkBuB,EAAOG,UAAS,SACrCzB,IAAA,WAEM,OAAAwB,KAAAD,YAAPf,oBAEa,gBACR,IAETc,EAAAG,UAACK,MAAA,SAAAjB,EAAAF,QAAA,IAAAA,IAAAA,EAAA,4JC5DAW,EDuCI,KCrEkC,oBAE/BS,cAOQN,UAAMb,IAAA,SAAAM,OACVc,EAAAR,KAAAS,OAAAf,UACIA,EAAAP,YACA,EACP,KAAA,EACJuB,QAAAtB,IAAAoB,6CAOOE,QAAAf,MAAAa,KASXD,EAAAN,UAAAQ,OAAA,SAAAf,GAED,IAAAc,kHAhCsC,KA4CwB,oBAQjDG,EAAcC,GACtBZ,KAAAY,OAAAA,uDATyD","sourcesContent":["import { LogLevel } from \"./loglevel\";\nimport { LogListener } from \"./listeners\";\nimport { LogEntry } from \"./logentry\";\n\n/**\n * Class used to subscribe ILogListener and log messages throughout an application\n *\n */\nexport class Logger {\n\n    private static _instance: LoggerImpl;\n\n    /**\n     * Gets or sets the active log level to apply for log filtering\n     */\n    public static get activeLogLevel(): LogLevel {\n        return Logger.instance.activeLogLevel;\n    }\n\n    public static set activeLogLevel(value: LogLevel) {\n        Logger.instance.activeLogLevel = value;\n    }\n\n    private static get instance(): LoggerImpl {\n        if (typeof Logger._instance === \"undefined\" || Logger._instance === null) {\n            Logger._instance = new LoggerImpl();\n        }\n        return Logger._instance;\n    }\n\n    /**\n     * Adds ILogListener instances to the set of subscribed listeners\n     *\n     * @param listeners One or more listeners to subscribe to this log\n     */\n    public static subscribe(...listeners: LogListener[]): void {\n        listeners.map(listener => Logger.instance.subscribe(listener));\n    }\n\n    /**\n     * Clears the subscribers collection, returning the collection before modifiction\n     */\n    public static clearSubscribers(): LogListener[] {\n        return Logger.instance.clearSubscribers();\n    }\n\n    /**\n     * Gets the current subscriber count\n     */\n    public static get count(): number {\n        return Logger.instance.count;\n    }\n\n    /**\n     * Writes the supplied string to the subscribed listeners\n     *\n     * @param message The message to write\n     * @param level [Optional] if supplied will be used as the level of the entry (Default: LogLevel.Verbose)\n     */\n    public static write(message: string, level: LogLevel = LogLevel.Verbose) {\n        Logger.instance.log({ level: level, message: message });\n    }\n\n    /**\n     * Writes the supplied string to the subscribed listeners\n     *\n     * @param json The json object to stringify and write\n     * @param level [Optional] if supplied will be used as the level of the entry (Default: LogLevel.Verbose)\n     */\n    public static writeJSON(json: any, level: LogLevel = LogLevel.Verbose) {\n        Logger.instance.log({ level: level, message: JSON.stringify(json) });\n    }\n\n    /**\n     * Logs the supplied entry to the subscribed listeners\n     *\n     * @param entry The message to log\n     */\n    public static log(entry: LogEntry) {\n        Logger.instance.log(entry);\n    }\n\n    /**\n     * Logs an error object to the subscribed listeners\n     * \n     * @param err The error object\n     */\n    public static error(err: Error) {\n        Logger.instance.log({ data: err, level: LogLevel.Error, message: err.message });\n    }\n}\n\nclass LoggerImpl {\n\n    constructor(public activeLogLevel: LogLevel = LogLevel.Warning, private subscribers: LogListener[] = []) { }\n\n    public subscribe(listener: LogListener): void {\n        this.subscribers.push(listener);\n    }\n\n    public clearSubscribers(): LogListener[] {\n        const s = this.subscribers.slice(0);\n        this.subscribers.length = 0;\n        return s;\n    }\n\n    public get count(): number {\n        return this.subscribers.length;\n    }\n\n    public write(message: string, level: LogLevel = LogLevel.Verbose) {\n        this.log({ level: level, message: message });\n    }\n\n    public log(entry: LogEntry) {\n        if (typeof entry !== \"undefined\" && this.activeLogLevel <= entry.level) {\n            this.subscribers.map(subscriber => subscriber.log(entry));\n        }\n    }\n}\n","import { LogEntry } from \"./logentry\";\nimport { LogLevel } from \"./loglevel\";\n\n/**\n * Interface that defines a log listner\n *\n */\nexport interface LogListener {\n    /**\n     * Any associated data that a given logging listener may choose to log or ignore\n     *\n     * @param entry The information to be logged\n     */\n    log(entry: LogEntry): void;\n}\n\n/**\n * Implementation of LogListener which logs to the console\n *\n */\nexport class ConsoleListener implements LogListener {\n\n    /**\n     * Any associated data that a given logging listener may choose to log or ignore\n     *\n     * @param entry The information to be logged\n     */\n    public log(entry: LogEntry): void {\n\n        const msg = this.format(entry);\n\n        switch (entry.level) {\n            case LogLevel.Verbose:\n            case LogLevel.Info:\n                console.log(msg);\n                break;\n            case LogLevel.Warning:\n                console.warn(msg);\n                break;\n            case LogLevel.Error:\n                console.error(msg);\n                break;\n        }\n    }\n\n    /**\n     * Formats the message\n     *\n     * @param entry The information to format into a string\n     */\n    private format(entry: LogEntry): string {\n        const msg = [];\n        msg.push(\"Message: \" + entry.message);\n        if (typeof entry.data !== \"undefined\") {\n            msg.push(\" Data: \" + JSON.stringify(entry.data));\n        }\n\n        return msg.join(\"\");\n    }\n}\n\n/**\n * Implementation of LogListener which logs to the supplied function\n *\n */\nexport class FunctionListener implements LogListener {\n\n    /**\n     * Creates a new instance of the FunctionListener class\n     *\n     * @constructor\n     * @param  method The method to which any logging data will be passed\n     */\n    constructor(private method: (entry: LogEntry) => void) { }\n\n    /**\n     * Any associated data that a given logging listener may choose to log or ignore\n     *\n     * @param entry The information to be logged\n     */\n    public log(entry: LogEntry): void {\n        this.method(entry);\n    }\n}\n"]}