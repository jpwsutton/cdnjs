{"version":3,"sources":["../../../../packages/logging/src/logger.ts","../../../../packages/logging/src/listeners.ts"],"names":["Logger","Object","defineProperty","instance","activeLogLevel","value","_instance","LoggerImpl","subscribe","listeners","_i","arguments","length","map","listener","clearSubscribers","count","write","message","level","log","writeJSON","json","JSON","stringify","entry","error","err","data","name","subscribers","this","prototype","push","s","slice","subscriber","ConsoleListener","msg","format","console","warn","join","FunctionListener","method"],"mappings":"gNAQA,IAAAA,EAAA,WAAA,SAAAA,KAkFA,OA3EIC,OAAAC,eAAkBF,EAAA,sBAAlB,WACI,OAAOA,EAAOG,SAASC,oBAG3B,SAAiCC,GAC7BL,EAAOG,SAASC,eAAiBC,mCAGrCJ,OAAAC,eAAmBF,EAAA,gBAAnB,WAII,YAHgC,IAArBA,EAAOM,WAAkD,OAArBN,EAAOM,YAClDN,EAAOM,UAAY,IAAIC,GAEpBP,EAAOM,2CAQJN,EAAAQ,UAAd,eAAwB,IAAAC,KAAAC,EAAA,EAAAA,EAAAC,UAAAC,OAAAF,IAAAD,EAAAC,GAAAC,UAAAD,GACpBD,EAAUI,IAAI,SAAAC,GAAY,OAAAd,EAAOG,SAASK,UAAUM,MAM1Cd,EAAAe,iBAAd,WACI,OAAOf,EAAOG,SAASY,oBAM3Bd,OAAAC,eAAkBF,EAAA,aAAlB,WACI,OAAOA,EAAOG,SAASa,uCASbhB,EAAAiB,MAAd,SAAoBC,EAAiBC,QAAA,IAAAA,IAAAA,EAAA,GACjCnB,EAAOG,SAASiB,KAAMD,MAAOA,EAAOD,QAASA,KASnClB,EAAAqB,UAAd,SAAwBC,EAAWH,QAAA,IAAAA,IAAAA,EAAA,GAC/BnB,EAAOG,SAASiB,KAAMD,MAAOA,EAAOD,QAASK,KAAKC,UAAUF,MAQlDtB,EAAAoB,IAAd,SAAkBK,GACdzB,EAAOG,SAASiB,IAAIK,IAQVzB,EAAA0B,MAAd,SAAoBC,GAChB3B,EAAOG,SAASiB,KAAMQ,KAAMD,EAAKR,MAAK,EAAkBD,QAAS,IAAIS,EAAIE,KAAI,MAAMF,EAAIT,WAE/FlB,EAlFA,GAoFAO,EAAA,WAEI,SAAAA,EAAmBH,EAAqD0B,QAArD,IAAA1B,IAAAA,EAAA,QAAqD,IAAA0B,IAAAA,MAArDC,KAAA3B,eAAAA,EAAqD2B,KAAAD,YAAAA,EAyB5E,OAvBWvB,EAAAyB,UAAAxB,UAAP,SAAiBM,GACbiB,KAAKD,YAAYG,KAAKnB,IAGnBP,EAAAyB,UAAAjB,iBAAP,WACI,IAAMmB,EAAIH,KAAKD,YAAYK,MAAM,GAEjC,OADAJ,KAAKD,YAAYlB,OAAS,EACnBsB,GAGXjC,OAAAC,eAAWK,EAAAyB,UAAA,aAAX,WACI,OAAOD,KAAKD,YAAYlB,wCAGrBL,EAAAyB,UAAAf,MAAP,SAAaC,EAAiBC,QAAA,IAAAA,IAAAA,EAAA,GAC1BY,KAAKX,KAAMD,MAAOA,EAAOD,QAASA,KAG/BX,EAAAyB,UAAAZ,IAAP,SAAWK,QACc,IAAVA,GAAyBM,KAAK3B,gBAAkBqB,EAAMN,OAC7DY,KAAKD,YAAYjB,IAAI,SAAAuB,GAAc,OAAAA,EAAWhB,IAAIK,MAG9DlB,EA3BA,GCxEA8B,EAAA,WAAA,SAAAA,KAuCA,OAhCWA,EAAAL,UAAAZ,IAAP,SAAWK,GAEP,IAAMa,EAAMP,KAAKQ,OAAOd,GAExB,OAAQA,EAAMN,OACV,KAAA,EACA,KAAA,EACIqB,QAAQpB,IAAIkB,GACZ,MACJ,KAAA,EACIE,QAAQC,KAAKH,GACb,MACJ,KAAA,EACIE,QAAQd,MAAMY,KAUlBD,EAAAL,UAAAO,OAAR,SAAed,GACX,IAAMa,KAMN,OALAA,EAAIL,KAAK,YAAcR,EAAMP,cACH,IAAfO,EAAMG,MACbU,EAAIL,KAAK,UAAYV,KAAKC,UAAUC,EAAMG,OAGvCU,EAAII,KAAK,KAExBL,EAvCA,GA6CAM,EAAA,WAQI,SAAAA,EAAoBC,GAAAb,KAAAa,OAAAA,EAUxB,OAHWD,EAAAX,UAAAZ,IAAP,SAAWK,GACPM,KAAKa,OAAOnB,IAEpBkB,EAlBA","sourcesContent":["import { LogLevel } from \"./loglevel\";\nimport { LogListener } from \"./listeners\";\nimport { LogEntry } from \"./logentry\";\n\n/**\n * Class used to subscribe ILogListener and log messages throughout an application\n *\n */\nexport class Logger {\n\n    private static _instance: LoggerImpl;\n\n    /**\n     * Gets or sets the active log level to apply for log filtering\n     */\n    public static get activeLogLevel(): LogLevel {\n        return Logger.instance.activeLogLevel;\n    }\n\n    public static set activeLogLevel(value: LogLevel) {\n        Logger.instance.activeLogLevel = value;\n    }\n\n    private static get instance(): LoggerImpl {\n        if (typeof Logger._instance === \"undefined\" || Logger._instance === null) {\n            Logger._instance = new LoggerImpl();\n        }\n        return Logger._instance;\n    }\n\n    /**\n     * Adds ILogListener instances to the set of subscribed listeners\n     *\n     * @param listeners One or more listeners to subscribe to this log\n     */\n    public static subscribe(...listeners: LogListener[]): void {\n        listeners.map(listener => Logger.instance.subscribe(listener));\n    }\n\n    /**\n     * Clears the subscribers collection, returning the collection before modifiction\n     */\n    public static clearSubscribers(): LogListener[] {\n        return Logger.instance.clearSubscribers();\n    }\n\n    /**\n     * Gets the current subscriber count\n     */\n    public static get count(): number {\n        return Logger.instance.count;\n    }\n\n    /**\n     * Writes the supplied string to the subscribed listeners\n     *\n     * @param message The message to write\n     * @param level [Optional] if supplied will be used as the level of the entry (Default: LogLevel.Verbose)\n     */\n    public static write(message: string, level: LogLevel = LogLevel.Verbose) {\n        Logger.instance.log({ level: level, message: message });\n    }\n\n    /**\n     * Writes the supplied string to the subscribed listeners\n     *\n     * @param json The json object to stringify and write\n     * @param level [Optional] if supplied will be used as the level of the entry (Default: LogLevel.Verbose)\n     */\n    public static writeJSON(json: any, level: LogLevel = LogLevel.Verbose) {\n        Logger.instance.log({ level: level, message: JSON.stringify(json) });\n    }\n\n    /**\n     * Logs the supplied entry to the subscribed listeners\n     *\n     * @param entry The message to log\n     */\n    public static log(entry: LogEntry) {\n        Logger.instance.log(entry);\n    }\n\n    /**\n     * Logs an error object to the subscribed listeners\n     * \n     * @param err The error object\n     */\n    public static error(err: Error) {\n        Logger.instance.log({ data: err, level: LogLevel.Error, message: `[${err.name}]::${err.message}` });\n    }\n}\n\nclass LoggerImpl {\n\n    constructor(public activeLogLevel: LogLevel = LogLevel.Warning, private subscribers: LogListener[] = []) { }\n\n    public subscribe(listener: LogListener): void {\n        this.subscribers.push(listener);\n    }\n\n    public clearSubscribers(): LogListener[] {\n        const s = this.subscribers.slice(0);\n        this.subscribers.length = 0;\n        return s;\n    }\n\n    public get count(): number {\n        return this.subscribers.length;\n    }\n\n    public write(message: string, level: LogLevel = LogLevel.Verbose) {\n        this.log({ level: level, message: message });\n    }\n\n    public log(entry: LogEntry) {\n        if (typeof entry !== \"undefined\" && this.activeLogLevel <= entry.level) {\n            this.subscribers.map(subscriber => subscriber.log(entry));\n        }\n    }\n}\n","import { LogEntry } from \"./logentry\";\nimport { LogLevel } from \"./loglevel\";\n\n/**\n * Interface that defines a log listner\n *\n */\nexport interface LogListener {\n    /**\n     * Any associated data that a given logging listener may choose to log or ignore\n     *\n     * @param entry The information to be logged\n     */\n    log(entry: LogEntry): void;\n}\n\n/**\n * Implementation of LogListener which logs to the console\n *\n */\nexport class ConsoleListener implements LogListener {\n\n    /**\n     * Any associated data that a given logging listener may choose to log or ignore\n     *\n     * @param entry The information to be logged\n     */\n    public log(entry: LogEntry): void {\n\n        const msg = this.format(entry);\n\n        switch (entry.level) {\n            case LogLevel.Verbose:\n            case LogLevel.Info:\n                console.log(msg);\n                break;\n            case LogLevel.Warning:\n                console.warn(msg);\n                break;\n            case LogLevel.Error:\n                console.error(msg);\n                break;\n        }\n    }\n\n    /**\n     * Formats the message\n     *\n     * @param entry The information to format into a string\n     */\n    private format(entry: LogEntry): string {\n        const msg = [];\n        msg.push(\"Message: \" + entry.message);\n        if (typeof entry.data !== \"undefined\") {\n            msg.push(\" Data: \" + JSON.stringify(entry.data));\n        }\n\n        return msg.join(\"\");\n    }\n}\n\n/**\n * Implementation of LogListener which logs to the supplied function\n *\n */\nexport class FunctionListener implements LogListener {\n\n    /**\n     * Creates a new instance of the FunctionListener class\n     *\n     * @constructor\n     * @param  method The method to which any logging data will be passed\n     */\n    constructor(private method: (entry: LogEntry) => void) { }\n\n    /**\n     * Any associated data that a given logging listener may choose to log or ignore\n     *\n     * @param entry The information to be logged\n     */\n    public log(entry: LogEntry): void {\n        this.method(entry);\n    }\n}\n"]}