{"version":3,"sources":["../../../../packages/logging/src/logger.ts","../../../../packages/logging/src/listeners.ts"],"names":["Logger","Object","defineProperty","instance","activeLogLevel","value","_instance","LoggerImpl","subscribe","listeners","_i","arguments","length","map","listener","clearSubscribers","count","write","message","level","log","writeJSON","json","JSON","stringify","entry","subscribers","this","prototype","push","s","slice","subscriber","ConsoleListener","msg","format","console","warn","error","data","join","FunctionListener","method"],"mappings":"gNAQA,IAAAA,EAAA,WAAA,SAAAA,KAyEA,OAlEIC,OAAAC,eAAkBF,EAAA,sBAAlB,WACI,OAAOA,EAAOG,SAASC,oBAG3B,SAAiCC,GAC7BL,EAAOG,SAASC,eAAiBC,mCAGrCJ,OAAAC,eAAmBF,EAAA,gBAAnB,WAII,YAHgC,IAArBA,EAAOM,WAAkD,OAArBN,EAAOM,YAClDN,EAAOM,UAAY,IAAIC,GAEpBP,EAAOM,2CAQJN,EAAAQ,UAAd,eAAwB,IAAAC,KAAAC,EAAA,EAAAA,EAAAC,UAAAC,OAAAF,IAAAD,EAAAC,GAAAC,UAAAD,GACpBD,EAAUI,IAAI,SAAAC,GAAY,OAAAd,EAAOG,SAASK,UAAUM,MAM1Cd,EAAAe,iBAAd,WACI,OAAOf,EAAOG,SAASY,oBAM3Bd,OAAAC,eAAkBF,EAAA,aAAlB,WACI,OAAOA,EAAOG,SAASa,uCASbhB,EAAAiB,MAAd,SAAoBC,EAAiBC,QAAA,IAAAA,IAAAA,EAAA,GACjCnB,EAAOG,SAASiB,KAAMD,MAAOA,EAAOD,QAASA,KASnClB,EAAAqB,UAAd,SAAwBC,EAAWH,QAAA,IAAAA,IAAAA,EAAA,GAC/BnB,EAAOG,SAASiB,KAAMD,MAAOA,EAAOD,QAASK,KAAKC,UAAUF,MAQlDtB,EAAAoB,IAAd,SAAkBK,GACdzB,EAAOG,SAASiB,IAAIK,IAE5BzB,EAzEA,GA2EAO,EAAA,WAEI,SAAAA,EAAmBH,EAAqDsB,QAArD,IAAAtB,IAAAA,EAAA,QAAqD,IAAAsB,IAAAA,MAArDC,KAAAvB,eAAAA,EAAqDuB,KAAAD,YAAAA,EAyB5E,OAvBWnB,EAAAqB,UAAApB,UAAP,SAAiBM,GACba,KAAKD,YAAYG,KAAKf,IAGnBP,EAAAqB,UAAAb,iBAAP,WACI,IAAMe,EAAIH,KAAKD,YAAYK,MAAM,GAEjC,OADAJ,KAAKD,YAAYd,OAAS,EACnBkB,GAGX7B,OAAAC,eAAWK,EAAAqB,UAAA,aAAX,WACI,OAAOD,KAAKD,YAAYd,wCAGrBL,EAAAqB,UAAAX,MAAP,SAAaC,EAAiBC,QAAA,IAAAA,IAAAA,EAAA,GAC1BQ,KAAKP,KAAMD,MAAOA,EAAOD,QAASA,KAG/BX,EAAAqB,UAAAR,IAAP,SAAWK,QACc,IAAVA,GAAyBE,KAAKvB,gBAAkBqB,EAAMN,OAC7DQ,KAAKD,YAAYb,IAAI,SAAAmB,GAAc,OAAAA,EAAWZ,IAAIK,MAG9DlB,EA3BA,GC/DA0B,EAAA,WAAA,SAAAA,KAuCA,OAhCWA,EAAAL,UAAAR,IAAP,SAAWK,GAEP,IAAMS,EAAMP,KAAKQ,OAAOV,GAExB,OAAQA,EAAMN,OACV,KAAA,EACA,KAAA,EACIiB,QAAQhB,IAAIc,GACZ,MACJ,KAAA,EACIE,QAAQC,KAAKH,GACb,MACJ,KAAA,EACIE,QAAQE,MAAMJ,KAUlBD,EAAAL,UAAAO,OAAR,SAAeV,GACX,IAAMS,KAMN,OALAA,EAAIL,KAAK,YAAcJ,EAAMP,cACH,IAAfO,EAAMc,MACbL,EAAIL,KAAK,UAAYN,KAAKC,UAAUC,EAAMc,OAGvCL,EAAIM,KAAK,KAExBP,EAvCA,GA6CAQ,EAAA,WAQI,SAAAA,EAAoBC,GAAAf,KAAAe,OAAAA,EAUxB,OAHWD,EAAAb,UAAAR,IAAP,SAAWK,GACPE,KAAKe,OAAOjB,IAEpBgB,EAlBA","sourcesContent":["import { LogLevel } from \"./loglevel\";\r\nimport { LogListener } from \"./listeners\";\r\nimport { LogEntry } from \"./logentry\";\r\n\r\n/**\r\n * Class used to subscribe ILogListener and log messages throughout an application\r\n *\r\n */\r\nexport class Logger {\r\n\r\n    private static _instance: LoggerImpl;\r\n\r\n    /**\r\n     * Gets or sets the active log level to apply for log filtering\r\n     */\r\n    public static get activeLogLevel(): LogLevel {\r\n        return Logger.instance.activeLogLevel;\r\n    }\r\n\r\n    public static set activeLogLevel(value: LogLevel) {\r\n        Logger.instance.activeLogLevel = value;\r\n    }\r\n\r\n    private static get instance(): LoggerImpl {\r\n        if (typeof Logger._instance === \"undefined\" || Logger._instance === null) {\r\n            Logger._instance = new LoggerImpl();\r\n        }\r\n        return Logger._instance;\r\n    }\r\n\r\n    /**\r\n     * Adds ILogListener instances to the set of subscribed listeners\r\n     *\r\n     * @param listeners One or more listeners to subscribe to this log\r\n     */\r\n    public static subscribe(...listeners: LogListener[]): void {\r\n        listeners.map(listener => Logger.instance.subscribe(listener));\r\n    }\r\n\r\n    /**\r\n     * Clears the subscribers collection, returning the collection before modifiction\r\n     */\r\n    public static clearSubscribers(): LogListener[] {\r\n        return Logger.instance.clearSubscribers();\r\n    }\r\n\r\n    /**\r\n     * Gets the current subscriber count\r\n     */\r\n    public static get count(): number {\r\n        return Logger.instance.count;\r\n    }\r\n\r\n    /**\r\n     * Writes the supplied string to the subscribed listeners\r\n     *\r\n     * @param message The message to write\r\n     * @param level [Optional] if supplied will be used as the level of the entry (Default: LogLevel.Verbose)\r\n     */\r\n    public static write(message: string, level: LogLevel = LogLevel.Verbose) {\r\n        Logger.instance.log({ level: level, message: message });\r\n    }\r\n\r\n    /**\r\n     * Writes the supplied string to the subscribed listeners\r\n     *\r\n     * @param json The json object to stringify and write\r\n     * @param level [Optional] if supplied will be used as the level of the entry (Default: LogLevel.Verbose)\r\n     */\r\n    public static writeJSON(json: any, level: LogLevel = LogLevel.Verbose) {\r\n        Logger.instance.log({ level: level, message: JSON.stringify(json) });\r\n    }\r\n\r\n    /**\r\n     * Logs the supplied entry to the subscribed listeners\r\n     *\r\n     * @param entry The message to log\r\n     */\r\n    public static log(entry: LogEntry) {\r\n        Logger.instance.log(entry);\r\n    }\r\n}\r\n\r\nclass LoggerImpl {\r\n\r\n    constructor(public activeLogLevel: LogLevel = LogLevel.Warning, private subscribers: LogListener[] = []) { }\r\n\r\n    public subscribe(listener: LogListener): void {\r\n        this.subscribers.push(listener);\r\n    }\r\n\r\n    public clearSubscribers(): LogListener[] {\r\n        const s = this.subscribers.slice(0);\r\n        this.subscribers.length = 0;\r\n        return s;\r\n    }\r\n\r\n    public get count(): number {\r\n        return this.subscribers.length;\r\n    }\r\n\r\n    public write(message: string, level: LogLevel = LogLevel.Verbose) {\r\n        this.log({ level: level, message: message });\r\n    }\r\n\r\n    public log(entry: LogEntry) {\r\n        if (typeof entry !== \"undefined\" && this.activeLogLevel <= entry.level) {\r\n            this.subscribers.map(subscriber => subscriber.log(entry));\r\n        }\r\n    }\r\n}\r\n","import { LogEntry } from \"./logentry\";\r\nimport { LogLevel } from \"./loglevel\";\r\n\r\n/**\r\n * Interface that defines a log listner\r\n *\r\n */\r\nexport interface LogListener {\r\n    /**\r\n     * Any associated data that a given logging listener may choose to log or ignore\r\n     *\r\n     * @param entry The information to be logged\r\n     */\r\n    log(entry: LogEntry): void;\r\n}\r\n\r\n/**\r\n * Implementation of LogListener which logs to the console\r\n *\r\n */\r\nexport class ConsoleListener implements LogListener {\r\n\r\n    /**\r\n     * Any associated data that a given logging listener may choose to log or ignore\r\n     *\r\n     * @param entry The information to be logged\r\n     */\r\n    public log(entry: LogEntry): void {\r\n\r\n        const msg = this.format(entry);\r\n\r\n        switch (entry.level) {\r\n            case LogLevel.Verbose:\r\n            case LogLevel.Info:\r\n                console.log(msg);\r\n                break;\r\n            case LogLevel.Warning:\r\n                console.warn(msg);\r\n                break;\r\n            case LogLevel.Error:\r\n                console.error(msg);\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Formats the message\r\n     *\r\n     * @param entry The information to format into a string\r\n     */\r\n    private format(entry: LogEntry): string {\r\n        const msg = [];\r\n        msg.push(\"Message: \" + entry.message);\r\n        if (typeof entry.data !== \"undefined\") {\r\n            msg.push(\" Data: \" + JSON.stringify(entry.data));\r\n        }\r\n\r\n        return msg.join(\"\");\r\n    }\r\n}\r\n\r\n/**\r\n * Implementation of LogListener which logs to the supplied function\r\n *\r\n */\r\nexport class FunctionListener implements LogListener {\r\n\r\n    /**\r\n     * Creates a new instance of the FunctionListener class\r\n     *\r\n     * @constructor\r\n     * @param  method The method to which any logging data will be passed\r\n     */\r\n    constructor(private method: (entry: LogEntry) => void) { }\r\n\r\n    /**\r\n     * Any associated data that a given logging listener may choose to log or ignore\r\n     *\r\n     * @param entry The information to be logged\r\n     */\r\n    public log(entry: LogEntry): void {\r\n        this.method(entry);\r\n    }\r\n}\r\n"]}