(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.weblas = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
function sgemm(e,t,r,a,l,u,c,o){var n,s=l,g=r%WebGL.COMPONENTS_PER_TEXEL,T=0==g?0:WebGL.COMPONENTS_PER_TEXEL-g;n=transpose(r,t,u);var x=gl.createDataTexture(e,r,s),E=gl.createDataTexture(t,r,n),i=gl.createOutputTexture(e,t);return sgemmcalculator.calculate(e,t,r+T,a,x,E,null,null,i),rawBuffer=gl.readData(e,t),gl.context.deleteTexture(x),gl.context.deleteTexture(E),gl.context.deleteTexture(i),new Float32Array(rawBuffer)}function saxpy(e,t,r,a){var l,u,c=e%WebGL.COMPONENTS_PER_TEXEL,o=0==c?0:WebGL.COMPONENTS_PER_TEXEL-c,n=r;isFloat32Array(a)?u=a:(u=new Float32Array(e),u.fill(a));var s=gl.createDataTexture(1,e,n),g=gl.createDataTexture(1,e,u),T=gl.createOutputTexture(1,e+o);return saxpycalculator.calculate(e+o,t,s,g,T),l=gl.readData(1,e),gl.context.deleteTexture(s),gl.context.deleteTexture(g),gl.context.deleteTexture(T),new Float32Array(l)}function isFloat32Array(e){return"[object Float32Array]"===Object.prototype.toString.call(e)}function sscal(e,t,r,a,l){var u,c=t%WebGL.COMPONENTS_PER_TEXEL,o=0==c?0:WebGL.COMPONENTS_PER_TEXEL-c,n=a,s=gl.createDataTexture(e,t,n),g=gl.createOutputTexture(e,t+o);return sscalcalculator.calculate(e,t,r,s,l,g),u=gl.readData(e,t),gl.context.deleteTexture(s),gl.context.deleteTexture(g),new Float32Array(u)}function sstd(e,t,r,a,l){var u,c=t%WebGL.COMPONENTS_PER_TEXEL,o=0==c?0:WebGL.COMPONENTS_PER_TEXEL-c,n=l,s=gl.createDataTexture(e,t,n),g=gl.createOutputTexture(e,t+o);return sscalcalculator.calculate(e,t+o,1/a,s,-1*r/a,g),u=gl.readData(e,t),gl.context.deleteTexture(s),gl.context.deleteTexture(g),new Float32Array(u)}function sdwns(e,t,r,a,l,u){var c=Math.floor(r/WebGL.COMPONENTS_PER_TEXEL),o=gl.createDataTexture(e,t*r,u),n=Math.floor((t-a)/l)+1,s=Math.floor((e-a)/l)+1,g=gl.createOutputTexture(s,n*r);return sdwnscalculator.calculate(e,t,c,a,l,o,g),rawBuffer=gl.readData(s,n*r),gl.context.deleteTexture(o),gl.context.deleteTexture(g),new Float32Array(rawBuffer)}function sclmp(e,t,r,a,l){r=null!=r?r:Number.MIN_VALUE,a=null!=a?a:Number.MAX_VALUE;var u,c=t%WebGL.COMPONENTS_PER_TEXEL,o=0==c?0:WebGL.COMPONENTS_PER_TEXEL-c,n=l,s=gl.createDataTexture(e,t,n),g=gl.createOutputTexture(e,t+o);return sclmpcalculator.calculate(e,t,r,a,s,g),u=gl.readData(e,t),gl.context.deleteTexture(s),gl.context.deleteTexture(g),new Float32Array(u)}function isNumeric(e){return e-parseFloat(e)+1>=0}function fromArray(e,t,r){var a,l,u=[];r?(u[1]=e.length,u[0]=e[0].length):(u[0]=e.length,u[1]=e[0].length),l=u[1],t=t||Float32Array,a=new t(u[0]*u[1]);for(var c=0;c<u[0];++c)for(var o=0;o<u[1];++o)r?a[c*l+o]=e[o][c]:a[c*l+o]=e[c][o];return a}function transpose(e,t,r){for(var a=new r.constructor(e*t),l=0;e>l;l++)for(var u=0;t>u;u++)a[u*e+l]=r[l*t+u];return a}var WebGL=require("./lib/webgl"),SGEMMCalculator=require("./lib/sgemmcalculator"),SAXPYCalculator=require("./lib/saxpycalculator"),SSCALCalculator=require("./lib/sscalcalculator"),SDWNSCalculator=require("./lib/sdwnscalculator"),SCLMPCalculator=require("./lib/sclmpcalculator"),test=require("./lib/test"),gl=new WebGL,sgemmcalculator=new SGEMMCalculator(gl),saxpycalculator=new SAXPYCalculator(gl),sscalcalculator=new SSCALCalculator(gl),sdwnscalculator=new SDWNSCalculator(gl),sclmpcalculator=new SCLMPCalculator(gl);module.exports={saxpy:saxpy,sscal:sscal,sgemm:sgemm,sstd:sstd,sdwns:sdwns,sclmp:sclmp,gl:gl,util:{fromArray:fromArray,transpose:transpose},test:test},String.prototype.format||(String.prototype.format=function(){var e=arguments;return this.replace(/{(\d+)}/g,function(t,r){return"undefined"!=typeof e[r]?e[r]:t})});
},{"./lib/saxpycalculator":2,"./lib/sclmpcalculator":3,"./lib/sdwnscalculator":4,"./lib/sgemmcalculator":5,"./lib/sscalcalculator":6,"./lib/test":7,"./lib/webgl":8}],2:[function(require,module,exports){
function SAXPYCalculator(t,e){this.webgl=t,this.standalone=e||!0,this.standalone?this.program=this.webgl.createProgram(SAXPYCalculator.STANDALONE_FRAGMENT_SHADER):this.program=this.webgl.createProgram(SAXPYCalculator.PIPELINE_FRAGMENT_SHADER)}var WebGL=require("./webgl");module.exports=SAXPYCalculator,SAXPYCalculator.TEXTURE_UNIFORM_NAME_0="X",SAXPYCalculator.TEXTURE_UNIFORM_NAME_1="Y",SAXPYCalculator.LENGTH_UNIFORM_NAME="N",SAXPYCalculator.COEFFICIENT_UNIFORM_NAME="a",SAXPYCalculator.STANDALONE_FRAGMENT_SHADER="                           \nprecision highp float;                                                   \n																		 \nvarying vec2      outTex;	// texture coords of row/column to calculate \nuniform sampler2D X;		// texture with data from padded A           \nuniform sampler2D Y;		// texture with data from padded transpose of B \nuniform int N; \nuniform float a; 		// coefficient to multiplication             \n	                                                              		\n"+WebGL.ENCODE_FLOAT_FUNCTION+WebGL.SELECT_CHANNEL_FUNCTION+"																		 \n                                                                      \n																		 \nvoid main(void) {                                                        \n																		 \n	// get the implied row and column from .y and .x of passed (output)  \n	// texture coordinate. These map directly to input texture space when\n	// the relevant dimensions are the same.                             \n 	float row = outTex.y;                                                \n	float col = outTex.x;                                                \n																		 \n	// direct usage of col requires output be padded exactly like input	 \n	vec4 x = texture2D( X, vec2(col, row));                                  \n	vec4 y = texture2D( Y, vec2(col, row));                                  \n	vec4 sum_v = (a * x) + y;                                    \n	int channel = int(mod(col * float(N), 4.0 )); \n	float sum = selectIndex(sum_v, channel); \n	\n	if (sum == 0.) {                                                     \n		gl_FragColor = vec4(0.,0.,0.,0.);                                \n		return;                                                          \n	}                                                                    \n																		 \n 	// output vec4 with bytes for an IEEE754 32-bit floating point number\n	gl_FragColor = encodeFloat(sum);									 \n}                                                                        \n",SAXPYCalculator.prototype.calculate=function(t,e,o,n,r){var a=this.webgl.context;this.webgl.selectProgram(this.program),this.bindInputTexture(o,a.TEXTURE0,SAXPYCalculator.TEXTURE_UNIFORM_NAME_0),this.bindInputTexture(n,a.TEXTURE1,SAXPYCalculator.TEXTURE_UNIFORM_NAME_1),this.bindUniforms(t,e),this.webgl.bindOutputTexture(1,t,r),a.drawElements(a.TRIANGLES,6,a.UNSIGNED_SHORT,0),this.webgl.unbindInputTexture(a.TEXTURE0),this.webgl.unbindInputTexture(a.TEXTURE1)},SAXPYCalculator.prototype.bindInputTexture=function(t,e,o){var n=this.webgl.context,r=this.program;n.activeTexture(e),n.bindTexture(n.TEXTURE_2D,t);var a=n.getUniformLocation(r,o);n.uniform1i(a,e-n.TEXTURE0)},SAXPYCalculator.prototype.bindUniforms=function(t,e){var o=this.webgl.context,n=o.getUniformLocation(this.program,SAXPYCalculator.LENGTH_UNIFORM_NAME),r=o.getUniformLocation(this.program,SAXPYCalculator.COEFFICIENT_UNIFORM_NAME);o.uniform1i(n,t),o.uniform1f(r,e)};
},{"./webgl":8}],3:[function(require,module,exports){
function SCLMPCalculator(t,n){this.webgl=t,this.standalone=n||!0,this.standalone?this.program=this.webgl.createProgram(SCLMPCalculator.STANDALONE_FRAGMENT_SHADER):this.program=this.webgl.createProgram(SCLMPCalculator.PIPELINE_FRAGMENT_SHADER)}var WebGL=require("./webgl");module.exports=SCLMPCalculator,SCLMPCalculator.TEXTURE_UNIFORM_NAME_0="X",SCLMPCalculator.LENGTH_UNIFORM_NAME="N",SCLMPCalculator.LOWER_UNIFORM_NAME="a",SCLMPCalculator.UPPER_UNIFORM_NAME="b",SCLMPCalculator.STANDALONE_FRAGMENT_SHADER="                           \nprecision highp float;                                                   \n																		 \nvarying vec2      outTex;	// texture coords of row/column to calculate \nuniform sampler2D X;		// texture with data from padded A           \nuniform int N; \nuniform int pad; \nuniform float a; 		// lower bound             \nuniform float b; 		// upper bound                        \n																		  \n"+WebGL.ENCODE_FLOAT_FUNCTION+WebGL.SELECT_CHANNEL_FUNCTION+"																		 \n                                                                      \n																		 \nvoid main(void) {                                                        \n																		 \n	// get the implied row and column from .y and .x of passed (output)  \n	// texture coordinate. These map directly to input texture space when\n	// the relevant dimensions are the same.                             \n	 float row = outTex.y;                                                \n	float col = outTex.x;                                                \n	\n	// return 0.0 if in padded region of output texture \n	if(col * float(N + pad) > float(N) ) {                               \n		gl_FragColor = vec4(0.,0.,0.,0.);                                \n		return;                                                          \n	}      \n	\n	// direct usage of col requires output be padded exactly like input	 \n	vec4 x = texture2D( X, vec2(col, row));                  \n	vec4 val = clamp(x, a, b);\n	// select and output channel (standalone version only)\n	int channel = int(mod(col * float(N + pad), 4.0 )); \n	float sum = selectIndex(val, channel); \n	\n	if (sum == 0.) {                                                     \n		gl_FragColor = vec4(0.,0.,0.,0.);                                \n		return;                                                          \n	}                                                                    \n																		 \n	 // output vec4 with bytes for an IEEE754 32-bit floating point number\n	gl_FragColor = encodeFloat(sum);									 \n}                                                                        \n",SCLMPCalculator.prototype.calculate=function(t,n,o,e,r,a){o=null!=o?o:Number.MIN_VALUE,e=null!=e?e:Number.MAX_VALUE;var l=this.webgl.context,i=n%WebGL.COMPONENTS_PER_TEXEL,u=0==i?0:WebGL.COMPONENTS_PER_TEXEL-i;this.webgl.selectProgram(this.program),this.bindInputTexture(r,l.TEXTURE0,SCLMPCalculator.TEXTURE_UNIFORM_NAME_0),this.bindUniforms(n,u,o,e),this.webgl.bindOutputTexture(t,n+u,a),l.drawElements(l.TRIANGLES,6,l.UNSIGNED_SHORT,0),this.webgl.unbindInputTexture(l.TEXTURE0)},SCLMPCalculator.prototype.bindInputTexture=function(t,n,o){var e=this.webgl.context,r=this.program;e.activeTexture(n),e.bindTexture(e.TEXTURE_2D,t);var a=e.getUniformLocation(r,o);e.uniform1i(a,n-e.TEXTURE0)},SCLMPCalculator.prototype.bindUniforms=function(t,n,o,e){var r=this.webgl.context,a=r.getUniformLocation(this.program,SCLMPCalculator.LENGTH_UNIFORM_NAME),l=r.getUniformLocation(this.program,SCLMPCalculator.UPPER_UNIFORM_NAME),i=r.getUniformLocation(this.program,SCLMPCalculator.LOWER_UNIFORM_NAME),u=r.getUniformLocation(this.program,"pad");r.uniform1i(a,t),r.uniform1i(u,n),r.uniform1f(i,o),r.uniform1f(l,e)};
},{"./webgl":8}],4:[function(require,module,exports){
function DownsampleCalculator(o,t){this.webgl=o,this.standalone=t||!0,this.standalone?this.program=this.webgl.createProgram(DownsampleCalculator.STANDALONE_FRAGMENT_SHADER):this.program=this.webgl.createProgram(DownsampleCalculator.PIPELINE_FRAGMENT_SHADER)}var WebGL=require("./webgl");module.exports=DownsampleCalculator,DownsampleCalculator.TEXTURE_UNIFORM_NAME_0="X",DownsampleCalculator.INPUT_ROW_COUNT_UNIFORM_NAME="M",DownsampleCalculator.INPUT_COLUMN_COUNT_UNIFORM_NAME="N",DownsampleCalculator.OUTPUT_ROW_COUNT_UNIFORM_NAME="M_out",DownsampleCalculator.OUTPUT_COLUMN_COUNT_UNIFORM_NAME="N_out",DownsampleCalculator.FACTOR_UNIFORM_NAME="factor",DownsampleCalculator.STRIDE_UNIFORM_NAME="stride",DownsampleCalculator.CHANNEL_COUNT_UNIFORM_NAME="c",DownsampleCalculator.STANDALONE_FRAGMENT_SHADER="                      \nprecision highp float;                                                   \n																		 \nvarying vec2      outTex;	// texture coords of row/column to calculate \nuniform sampler2D X;		// texture with data from padded A           \nuniform int factor; // width of image patch\nuniform float stride; // width between image patches\nuniform float c; 		// number of channels \nuniform float M;\nuniform float N;\nuniform float N_out;\nuniform float M_out;\n	                                                              		\n"+WebGL.ENCODE_FLOAT_FUNCTION+WebGL.SELECT_CHANNEL_FUNCTION+"																		 \n                                                                      \n																		 \nvoid main(void) {                                                        \n																		 \n	// get the implied row and column from .y and .x of passed (output)  \n	// texture coordinate and translate to input texture space.          \n	float row_p = floor(outTex.y * M_out);   // row on output texture (pixel space)   \n	float col_p = floor(outTex.x * N_out/4.0); // column on output texture (pixel space)\n	float vcol_p = floor(col_p / c);   // virtual column on output texture (pixel space)\n	float vchannel_p = mod(col_p, c); // virtual channel on output texture\n	\n																			\n	const float min = -1.0e+08;\n	vec4 currentMax = vec4(min, min, min, min); \n	\n	float deltaY = 1.0/M;\n	float deltaX = 4.0/N;\n	float y = ((row_p * stride) + 0.5)*deltaY; // position of input row				\n	float x; \n	float z = vchannel_p * deltaX;\n	for (int i = 0; i < 100; i += 1) {										\n		if (i >= factor) {													\n			break;															\n		}																	\n		x = ((vcol_p * stride * c) + 0.5) * deltaX; // position of input column	\n																			\n		for (int j = 0; j < 100; j += 1) {									\n			if (j >= factor) {												\n				break;														\n			}																\n																			\n			vec2 coords = vec2(x + z, y); \n	        vec4 x_v = texture2D(X, coords);				\n	        currentMax = max(currentMax, x_v);								\n																			\n			x += (deltaX * c);											\n		}																	\n		y += deltaY;															\n	}																		\n	int chan = int(mod(outTex.x * N_out, 4.0 )); \n	float val = selectIndex(currentMax, int(chan)); \n	if (val == 0.) {                                                 \n		gl_FragColor = vec4(0.,0.,0.,0.);                                \n		return;                                                          \n	}                                                                   \n	\n	gl_FragColor = encodeFloat(val);\n}",DownsampleCalculator.prototype.calculate=function(o,t,n,a,e,r,l){var i=this.webgl.context,u=(Math.floor((t-a)/e)+1)*n*WebGL.COMPONENTS_PER_TEXEL,c=Math.floor((o-a)/e)+1;this.webgl.selectProgram(this.program),this.bindInputTexture(r,i.TEXTURE0,DownsampleCalculator.TEXTURE_UNIFORM_NAME_0),this.bindUniforms(o,t*n*WebGL.COMPONENTS_PER_TEXEL,c,u,a,e,n),this.webgl.bindOutputTexture(c,u,l),i.drawElements(i.TRIANGLES,6,i.UNSIGNED_SHORT,0),this.webgl.unbindInputTexture(i.TEXTURE0)},DownsampleCalculator.prototype.bindInputTexture=function(o,t,n){var a=this.webgl.context,e=this.program;a.activeTexture(t),a.bindTexture(a.TEXTURE_2D,o);var r=a.getUniformLocation(e,n);a.uniform1i(r,t-a.TEXTURE0)},DownsampleCalculator.prototype.bindUniforms=function(o,t,n,a,e,r,l){var i=this.webgl.context,u=i.getUniformLocation(this.program,DownsampleCalculator.INPUT_ROW_COUNT_UNIFORM_NAME),c=i.getUniformLocation(this.program,DownsampleCalculator.INPUT_COLUMN_COUNT_UNIFORM_NAME),_=i.getUniformLocation(this.program,DownsampleCalculator.OUTPUT_ROW_COUNT_UNIFORM_NAME),m=i.getUniformLocation(this.program,DownsampleCalculator.OUTPUT_COLUMN_COUNT_UNIFORM_NAME),N=i.getUniformLocation(this.program,DownsampleCalculator.FACTOR_UNIFORM_NAME),p=i.getUniformLocation(this.program,DownsampleCalculator.STRIDE_UNIFORM_NAME),s=i.getUniformLocation(this.program,DownsampleCalculator.CHANNEL_COUNT_UNIFORM_NAME);i.uniform1f(u,o),i.uniform1f(c,t),i.uniform1f(_,n),i.uniform1f(m,a),i.uniform1i(N,e),i.uniform1f(p,r),i.uniform1f(s,l)};
},{"./webgl":8}],5:[function(require,module,exports){
function SGEMMCalculator(t,e){this.webgl=t,this.standalone=e||!0,this.standalone?this.program=this.webgl.createProgram(SGEMMCalculator.STANDALONE_FRAGMENT_SHADER):this.program=this.webgl.createProgram(SGEMMCalculator.PIPELINE_FRAGMENT_SHADER)}var WebGL=require("./webgl");module.exports=SGEMMCalculator,SGEMMCalculator.TEXTURE_UNIFORM_NAME_0="A",SGEMMCalculator.TEXTURE_UNIFORM_NAME_1="B_t",SGEMMCalculator.SHARED_LENGTH_UNIFORM_NAME="K",SGEMMCalculator.ALPHA_UNIFORM_NAME="alpha",SGEMMCalculator.DOT_FUNCTION="\n float delta_t = 1./float(K);// space (on texture) between elements     \n 																		 \n// sum of products between elements in row i (from A) x col j (from B)   \n//																		 \n// Calculate the dot product between the row (from A) and column (from B)\n// identified by the passed indeces (output texture coordinate space).   \n// We loop over elements in the row and column and sum the product       \n// using the glsl `dot` function to process four elements at a time.     \n// This four element optimization requires that the matrix B be          \n// transposed before texel packing and that both matrices be padded      \n// (with zeros) to a multiple of four (4) in their shared dimension.     \nfloat dot_rowcol(float x, float y) {                                     \n	float sum = 0.;			// sum for this row/column pair              \n	float z = 0.5 * (4.0 * delta_t);// position for shared dimension on source textures \n			 															\n	for (int l=0 ; l<4096 ; ++l) {                                       \n		if(l >= K / 4) break;    // stop when we finish the row/column   \n		// l is in pixel space, so we divide by four                     \n				 														\n		// retrieve next four elements from each texture                 \n		vec4 a_ik = texture2D(  A, vec2(z, x));                          \n		vec4 b_kj = texture2D(B_t, vec2(z, y));                          \n				 															\n		// use `dot` to process four elements at a time                  \n		sum += alpha * dot(a_ik, b_kj);                                  \n		z += (4.0 * delta_t);      // (z + 0.5)*delta                              \n	}                                                                    \n	return sum;                                                          \n}",SGEMMCalculator.STANDALONE_FRAGMENT_SHADER="                                  \n// fragment shader that calculates the matrix product and renders each   \n// element to the bytes representing a 32-bit IEEE754 floating point in  \n// the output RGBA canvas.                                               \n// readPixel is used to read the bytes.                                  \n																		 \nprecision highp float;                                                   \n																		 \nvarying vec2      outTex;	// texture coords of row/column to calculate \nuniform sampler2D A;		// texture with data from padded A           \nuniform sampler2D B_t;		// texture with data from padded transpose of B \nuniform int       K;		// number of elements in shared dimension    \nuniform float     alpha; 	// coefficient to multiplication             \n	                                                              		\n"+SGEMMCalculator.DOT_FUNCTION+WebGL.ENCODE_FLOAT_FUNCTION+"																		 \n																		 \nvoid main(void) {                                                        \n																		 \n	// get the implied row and column from .y and .x of passed (output)  \n	// texture coordinate. These map directly to input texture space when\n	// the relevant dimensions are the same.                             \n 	float row_t = outTex.y;                                                \n	float col_t = outTex.x;                                                \n																		 \n	// sum row x col for the passed pixel                                \n	float sum = dot_rowcol(row_t, col_t);                                    \n																		 \n	if (sum == 0.) {                                                     \n		gl_FragColor = vec4(0.,0.,0.,0.);                                \n		return;                                                          \n	}                                                                    \n																		 \n 	// output vec4 with bytes for an IEEE754 32-bit floating point number\n	gl_FragColor = encodeFloat(sum);									 \n}                                                                        \n",SGEMMCalculator.prototype.calculate=function(t,e,o,n,r,a,i,l,u){var s=this.webgl.context;this.webgl.selectProgram(this.program),this.bindInputTexture(r,s.TEXTURE0,SGEMMCalculator.TEXTURE_UNIFORM_NAME_0),this.bindInputTexture(a,s.TEXTURE1,SGEMMCalculator.TEXTURE_UNIFORM_NAME_1),this.bindUniforms(o,n),this.webgl.bindOutputTexture(t,e,u),s.drawElements(s.TRIANGLES,6,s.UNSIGNED_SHORT,0),this.webgl.unbindInputTexture(s.TEXTURE0),this.webgl.unbindInputTexture(s.TEXTURE1)},SGEMMCalculator.prototype.bindInputTexture=function(t,e,o){var n=this.webgl.context,r=this.program;n.activeTexture(e),n.bindTexture(n.TEXTURE_2D,t);var a=n.getUniformLocation(r,o);n.uniform1i(a,e-n.TEXTURE0)},SGEMMCalculator.prototype.bindUniforms=function(t,e){var o=this.webgl.context,n=o.getUniformLocation(this.program,SGEMMCalculator.SHARED_LENGTH_UNIFORM_NAME),r=o.getUniformLocation(this.program,SGEMMCalculator.ALPHA_UNIFORM_NAME);o.uniform1i(n,t),o.uniform1f(r,e)};
},{"./webgl":8}],6:[function(require,module,exports){
function SSCALCalculator(t,o){this.webgl=t,this.standalone=o||!0,this.standalone?this.program=this.webgl.createProgram(SSCALCalculator.STANDALONE_FRAGMENT_SHADER):this.program=this.webgl.createProgram(SSCALCalculator.PIPELINE_FRAGMENT_SHADER)}var WebGL=require("./webgl");module.exports=SSCALCalculator,SSCALCalculator.TEXTURE_UNIFORM_NAME_0="X",SSCALCalculator.LENGTH_UNIFORM_NAME="N",SSCALCalculator.ADD_UNIFORM_NAME="b",SSCALCalculator.MUL_UNIFORM_NAME="a",SSCALCalculator.STANDALONE_FRAGMENT_SHADER="                           \nprecision highp float;                                                   \n																		 \nvarying vec2      outTex;	// texture coords of row/column to calculate \nuniform sampler2D X;		// texture with data from padded A           \nuniform int N; \nuniform int pad; \nuniform float b; 		// additive term                        \nuniform float a; 		// multiplicative term             \n	                                                              		\n"+WebGL.ENCODE_FLOAT_FUNCTION+WebGL.SELECT_CHANNEL_FUNCTION+"																		 \n                                                                      \n																		 \nvoid main(void) {                                                        \n																		 \n	// get the implied row and column from .y and .x of passed (output)  \n	// texture coordinate. These map directly to input texture space when\n	// the relevant dimensions are the same.                             \n 	float row = outTex.y;                                                \n	float col = outTex.x;                                                \n	\n	// return 0.0 if in padded region of output texture \n	if(col * float(N + pad) > float(N) ) {                               \n		gl_FragColor = vec4(0.,0.,0.,0.);                                \n		return;                                                          \n	}      \n	\n	// direct usage of col requires output be padded exactly like input	 \n	vec4 x = texture2D( X, vec2(col, row));                  \n	vec4 sum_v = (a * x) + b;\n	int channel = int(mod(col * float(N + pad), 4.0 )); \n	float sum = selectIndex(sum_v, channel); \n	\n	if (sum == 0.) {                                                     \n		gl_FragColor = vec4(0.,0.,0.,0.);                                \n		return;                                                          \n	}                                                                    \n																		 \n 	// output vec4 with bytes for an IEEE754 32-bit floating point number\n	gl_FragColor = encodeFloat(sum);									 \n}                                                                        \n",SSCALCalculator.prototype.calculate=function(t,o,e,n,r,a){var i=this.webgl.context,l=o%WebGL.COMPONENTS_PER_TEXEL,u=0==l?0:WebGL.COMPONENTS_PER_TEXEL-l;this.webgl.selectProgram(this.program),this.bindInputTexture(n,i.TEXTURE0,SSCALCalculator.TEXTURE_UNIFORM_NAME_0),this.bindUniforms(o,u,e,r),this.webgl.bindOutputTexture(t,o+u,a),i.drawElements(i.TRIANGLES,6,i.UNSIGNED_SHORT,0),this.webgl.unbindInputTexture(i.TEXTURE0)},SSCALCalculator.prototype.bindInputTexture=function(t,o,e){var n=this.webgl.context,r=this.program;n.activeTexture(o),n.bindTexture(n.TEXTURE_2D,t);var a=n.getUniformLocation(r,e);n.uniform1i(a,o-n.TEXTURE0)},SSCALCalculator.prototype.bindUniforms=function(t,o,e,n){var r=this.webgl.context,a=r.getUniformLocation(this.program,SSCALCalculator.LENGTH_UNIFORM_NAME),i=r.getUniformLocation(this.program,SSCALCalculator.ADD_UNIFORM_NAME),l=r.getUniformLocation(this.program,SSCALCalculator.MUL_UNIFORM_NAME),u=r.getUniformLocation(this.program,"pad");r.uniform1i(a,t),r.uniform1i(u,o),r.uniform1f(l,e),r.uniform1f(i,n)};
},{"./webgl":8}],7:[function(require,module,exports){
var async=require("async"),loader=require("floader");test={},test.allclose=function(e,t,r,l){if(r=r||1e-5,l=l||1e-8,e.length!=t.length)return console.log("lengths not equal: "+e.length+", "+t.length),{result:!1,index:null};for(var a,n=0;n<e.length;n++)if(a=Math.abs(e[n]-t[n])<=l+r*Math.abs(t[n]),!a)return{result:!1,index:n};return{result:!0,index:n}},test.randomArray=function(e,t){for(var r=[],l=0;e>l;l++){for(var a=[],n=0;t>n;n++)a[n]=Math.random()/Math.sqrt(e);r.push(a)}return r},test.load=function(e,t,r){var l=t.map(function(t){return e+t});async.map(l,loader.load,function(e,t){if(e)return r(e);var l=t.map(JSON.parse);r(e,l)})},test.assert={},test.assert.allclose=function(e,t,r,l,a,n){var s=test.allclose(t,r,a,n),o="[..., ",u="[..., ";if(!s.result){for(var c=s.index;c<s.index+4&&c<t.length;c++)o+=t[c]+", ",u+=r[c]+", ";o+="...]",u+="...]",l=l||"should be allclose at "+s.index}e._assert(s.result,{message:l||"should be allclose",operator:"allclose",actual:o,expected:u,extra:null})},module.exports=test;
},{"async":9,"floader":10}],8:[function(require,module,exports){
function WebGL(e){var t,r;if(e=e||{},"undefined"==typeof e.canvas?this.canvas=document.createElement("canvas"):this.canvas=e.canvas,t={premultipliedAlpha:!1,preserveDrawingBuffer:!1},this.context=this.canvas.getContext("experimental-webgl",t),"undefined"==typeof this.context)throw new Error("No support for Webgl.");try{r=this.context.getExtension("OES_texture_float")}catch(a){}r?this.hasFloat=!0:(console.log("No support for OES_texture_float extension."),this.hasFloat=!1);var n=this.context.getShaderPrecisionFormat(this.context.FRAGMENT_SHADER,this.context.HIGH_FLOAT);this.hasHighPrecision=0!=n.precision,this.hasHighPrecision&&(this.highp=n),this.vertexShader=this.context.createShader(this.context.VERTEX_SHADER),this.context.shaderSource(this.vertexShader,WebGL.PASS_THROUGH_VERTEX_SHADER),this.context.compileShader(this.vertexShader)}module.exports=WebGL,WebGL.COMPONENTS_PER_TEXEL=4,WebGL.POSITION_UNIFORM_NAME="pos",WebGL.TEXTURE_UNIFORM_NAME="tex",WebGL.PASS_THROUGH_VERTEX_SHADER="// vertex shader for a single quad                                           \n// work is performed in the operation specific texture shader                \n		                                                                     \nprecision highp float;                                                       \n		                                                                     \nattribute vec3 pos;                                                         \nattribute vec2 tex;                                                         \nvarying vec2   outTex;                                                         \nvoid main(void)                                                              \n{                                                                            \n	// just pass the position and texture coords                             \n	gl_Position = vec4(pos, 1.0);                                           \n	outTex = tex;                                                             \n}                                                                            \n",WebGL.ENCODE_FLOAT_FUNCTION="\n// Render float to bytes according to IEEE 754 Floating Point            \nvec4 encodeFloat(float val) {                                            \n																	 \n// TODO: correctly handle denormal numbers                           \n// http://www.2ality.com/2012/04/number-encoding.html                \nfloat a = abs(val);                           // encode absolute value + sign \nfloat exp = floor(log2(a));                 // number of powers of 2 \nfloat mant = pow(2.,log2(a)-exp) * pow(2.,23.);  // multiply to fill 24 bits (implied leading 1) \nfloat mant1 = floor(mant / 256. / 256.);    // first 8 bits of mantissa \nfloat mant2 = mod(floor(mant / 256.),256.); // second 8 bits         \nfloat mant3 = mod(mant,256.);               // third 8 bits          \n																	 \nhighp float sign = 128.-128.*(a/val);			// sign bit is 256 or 0  \nhighp float e = (sign+exp+127.)/510.;		// exponent and sign     \nhighp float m1 = (mant1-(128.*(1.-mod(exp+127.,2.))))/255.; // handle leading bit \nhighp float m2 = (mant2)/255.;				// middle part           \nhighp float m3 = (mant3+.5)/255.;			// scale to 0 - 255      \n																	 \nreturn vec4(m3,m2,m1,e);                                             \n}",WebGL.SELECT_CHANNEL_FUNCTION="									\nfloat selectIndex(vec4 v, int index){								\n	float val;														\n	if (index == 0) {												\n		val = v.r;													\n	} else if(index == 1) {											\n		val = v.g;													\n	} else if(index == 2) {											\n		val = v.b;													\n	} else if(index == 3){											\n		val = v.a;													\n	} else {														\n		// should never be here										\n		val = 0.0;													\n	}																\n	return val;														\n}",WebGL.prototype.createProgram=function(e){var t,r=this.context;if(t=r.createShader(r.FRAGMENT_SHADER),r.shaderSource(t,e),r.compileShader(t),0==r.getShaderParameter(t,r.COMPILE_STATUS))throw new Error(r.getShaderInfoLog(t));var a=r.createProgram();return r.attachShader(a,this.vertexShader),r.attachShader(a,t),r.linkProgram(a),a},WebGL.prototype.selectProgram=function(e){var t=this.context;t.useProgram(e),this.bindVertices(e)},WebGL.prototype.bindVertices=function(e){var t=this.context,r=e,a=t.getAttribLocation(r,WebGL.POSITION_UNIFORM_NAME),n=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,n);var o=[-1,-1,0,1,-1,0,1,1,0,-1,1,0];t.bufferData(t.ARRAY_BUFFER,new Float32Array(o),t.STATIC_DRAW),t.vertexAttribPointer(a,3,t.FLOAT,!1,0,0),t.enableVertexAttribArray(a);var i=t.getAttribLocation(r,WebGL.TEXTURE_UNIFORM_NAME),E=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,E);var T=[0,0,1,0,1,1,0,1];t.bufferData(t.ARRAY_BUFFER,new Float32Array(T),t.STATIC_DRAW),t.vertexAttribPointer(i,2,t.FLOAT,!1,0,0),t.enableVertexAttribArray(i);var f=t.createBuffer();t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,f);var s=[0,1,2,0,2,3];t.bufferData(t.ELEMENT_ARRAY_BUFFER,new Uint16Array(s),t.STATIC_DRAW)},WebGL.prototype.createDataTexture=function(e,t,r){var a=this.context,n=4,o=0,i=t%n,E=0==i?0:n-i,T=a.createTexture();if(a.bindTexture(a.TEXTURE_2D,T),0==E||null==r||"undefined"==typeof r)a.texImage2D(a.TEXTURE_2D,0,a.RGBA,t/n,e,0,a.RGBA,a.FLOAT,r);else{a.texImage2D(a.TEXTURE_2D,0,a.RGBA,(t+E)/n,e,0,a.RGBA,a.FLOAT,null);for(var f,s,l=t-i,R=l/n,u=0,_=new Float32Array(n),h=0;e>h;h++)u=h*t,full_texel_row_end=u+l,f=new Float32Array(r.buffer,u*r.BYTES_PER_ELEMENT,l),l>0&&a.texSubImage2D(a.TEXTURE_2D,0,0,h,R,1,a.RGBA,a.FLOAT,f),_.fill(o),s=new Float32Array(r.buffer,full_texel_row_end*r.BYTES_PER_ELEMENT,i),_.set(s),a.texSubImage2D(a.TEXTURE_2D,0,R,h,1,1,a.RGBA,a.FLOAT,_)}return a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.NEAREST),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.NEAREST),a.bindTexture(a.TEXTURE_2D,null),T},WebGL.prototype.createOutputTexture=function(e,t){var r=this.context,a=r.createTexture();return r.bindTexture(r.TEXTURE_2D,a),r.texImage2D(r.TEXTURE_2D,0,r.RGBA,t,e,0,r.RGBA,r.UNSIGNED_BYTE,null),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.NEAREST),r.bindTexture(r.TEXTURE_2D,null),a},WebGL.prototype.bindOutputTexture=function(e,t,r){var a=this.context;if(this.canvas.height=e,this.canvas.width=t,a.viewport(0,0,t,e),this.framebuffer=this.framebuffer||a.createFramebuffer(),a.bindFramebuffer(a.FRAMEBUFFER,this.framebuffer),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,r,0),a.checkFramebufferStatus(a.FRAMEBUFFER)!=a.FRAMEBUFFER_COMPLETE)throw new Error("Bound framebuffer is not complete.");return this.framebuffer},WebGL.prototype.unbindInputTexture=function(e){var t=this.context;t.activeTexture(e),t.bindTexture(t.TEXTURE_2D,null)},WebGL.prototype.readData=function(e,t){var r=this.context;return rawbuffer=new ArrayBuffer(e*t*Float32Array.BYTES_PER_ELEMENT),prod=new Uint8Array(rawbuffer),r.readPixels(0,0,t,e,r.RGBA,r.UNSIGNED_BYTE,prod),rawbuffer};
},{}],9:[function(require,module,exports){
(function (process,global){
!function(){function n(){}function t(n){return n}function e(n){return!!n}function r(n){return!n}function u(n){return function(){if(null===n)throw new Error("Callback was already called.");n.apply(this,arguments),n=null}}function i(n){return function(){null!==n&&(n.apply(this,arguments),n=null)}}function o(n){return M(n)||"number"==typeof n.length&&n.length>=0&&n.length%1===0}function c(n,t){for(var e=-1,r=n.length;++e<r;)t(n[e],e,n)}function a(n,t){for(var e=-1,r=n.length,u=Array(r);++e<r;)u[e]=t(n[e],e,n);return u}function f(n){return a(Array(n),function(n,t){return t})}function l(n,t,e){return c(n,function(n,r,u){e=t(e,n,r,u)}),e}function s(n,t){c(W(n),function(e){t(n[e],e)})}function p(n,t){for(var e=0;e<n.length;e++)if(n[e]===t)return e;return-1}function h(n){var t,e,r=-1;return o(n)?(t=n.length,function(){return r++,t>r?r:null}):(e=W(n),t=e.length,function(){return r++,t>r?e[r]:null})}function m(n,t){return t=null==t?n.length-1:+t,function(){for(var e=Math.max(arguments.length-t,0),r=Array(e),u=0;e>u;u++)r[u]=arguments[u+t];switch(t){case 0:return n.call(this,r);case 1:return n.call(this,arguments[0],r)}}}function y(n){return function(t,e,r){return n(t,r)}}function v(t){return function(e,r,o){o=i(o||n),e=e||[];var c=h(e);if(0>=t)return o(null);var a=!1,f=0,l=!1;!function s(){if(a&&0>=f)return o(null);for(;t>f&&!l;){var n=c();if(null===n)return a=!0,void(0>=f&&o(null));f+=1,r(e[n],n,u(function(n){f-=1,n?(o(n),l=!0):s()}))}}()}}function d(n){return function(t,e,r){return n(C.eachOf,t,e,r)}}function g(n){return function(t,e,r,u){return n(v(e),t,r,u)}}function k(n){return function(t,e,r){return n(C.eachOfSeries,t,e,r)}}function b(t,e,r,u){u=i(u||n),e=e||[];var c=o(e)?[]:{};t(e,function(n,t,e){r(n,function(n,r){c[t]=r,e(n)})},function(n){u(n,c)})}function w(n,t,e,r){var u=[];n(t,function(n,t,r){e(n,function(e){e&&u.push({index:t,value:n}),r()})},function(){r(a(u.sort(function(n,t){return n.index-t.index}),function(n){return n.value}))})}function O(n,t,e,r){w(n,t,function(n,t){e(n,function(n){t(!n)})},r)}function S(n,t,e){return function(r,u,i,o){function c(){o&&o(e(!1,void 0))}function a(n,r,u){return o?void i(n,function(r){o&&t(r)&&(o(e(!0,n)),o=i=!1),u()}):u()}arguments.length>3?n(r,u,a,c):(o=i,i=u,n(r,a,c))}}function E(n,t){return t}function L(t,e,r){r=r||n;var u=o(e)?[]:{};t(e,function(n,t,e){n(m(function(n,r){r.length<=1&&(r=r[0]),u[t]=r,e(n)}))},function(n){r(n,u)})}function I(n,t,e,r){var u=[];n(t,function(n,t,r){e(n,function(n,t){u=u.concat(t||[]),r(n)})},function(n){r(n,u)})}function x(t,e,r){function i(t,e,r,u){if(null!=u&&"function"!=typeof u)throw new Error("task callback must be a function");return t.started=!0,M(e)||(e=[e]),0===e.length&&t.idle()?C.setImmediate(function(){t.drain()}):(c(e,function(e){var i={data:e,callback:u||n};r?t.tasks.unshift(i):t.tasks.push(i),t.tasks.length===t.concurrency&&t.saturated()}),void C.setImmediate(t.process))}function o(n,t){return function(){f-=1;var e=!1,r=arguments;c(t,function(n){c(l,function(t,r){t!==n||e||(l.splice(r,1),e=!0)}),n.callback.apply(n,r)}),n.tasks.length+f===0&&n.drain(),n.process()}}if(null==e)e=1;else if(0===e)throw new Error("Concurrency must not be zero");var f=0,l=[],s={tasks:[],concurrency:e,payload:r,saturated:n,empty:n,drain:n,started:!1,paused:!1,push:function(n,t){i(s,n,!1,t)},kill:function(){s.drain=n,s.tasks=[]},unshift:function(n,t){i(s,n,!0,t)},process:function(){if(!s.paused&&f<s.concurrency&&s.tasks.length)for(;f<s.concurrency&&s.tasks.length;){var n=s.payload?s.tasks.splice(0,s.payload):s.tasks.splice(0,s.tasks.length),e=a(n,function(n){return n.data});0===s.tasks.length&&s.empty(),f+=1,l.push(n[0]);var r=u(o(s,n));t(e,r)}},length:function(){return s.tasks.length},running:function(){return f},workersList:function(){return l},idle:function(){return s.tasks.length+f===0},pause:function(){s.paused=!0},resume:function(){if(s.paused!==!1){s.paused=!1;for(var n=Math.min(s.concurrency,s.tasks.length),t=1;n>=t;t++)C.setImmediate(s.process)}}};return s}function j(n){return m(function(t,e){t.apply(null,e.concat([m(function(t,e){"object"==typeof console&&(t?console.error&&console.error(t):console[n]&&c(e,function(t){console[n](t)}))})]))})}function A(n){return function(t,e,r){n(f(t),e,r)}}function T(n){return m(function(t,e){var r=m(function(e){var r=this,u=e.pop();return n(t,function(n,t,u){n.apply(r,e.concat([u]))},u)});return e.length?r.apply(this,e):r})}function z(n){return m(function(t){var e=t.pop();t.push(function(){var n=arguments;r?C.setImmediate(function(){e.apply(null,n)}):e.apply(null,n)});var r=!0;n.apply(this,t),r=!1})}var q,C={},P="object"==typeof self&&self.self===self&&self||"object"==typeof global&&global.global===global&&global||this;null!=P&&(q=P.async),C.noConflict=function(){return P.async=q,C};var H=Object.prototype.toString,M=Array.isArray||function(n){return"[object Array]"===H.call(n)},U=function(n){var t=typeof n;return"function"===t||"object"===t&&!!n},W=Object.keys||function(n){var t=[];for(var e in n)n.hasOwnProperty(e)&&t.push(e);return t},B="function"==typeof setImmediate&&setImmediate,D=B?function(n){B(n)}:function(n){setTimeout(n,0)};"object"==typeof process&&"function"==typeof process.nextTick?C.nextTick=process.nextTick:C.nextTick=D,C.setImmediate=B?D:C.nextTick,C.forEach=C.each=function(n,t,e){return C.eachOf(n,y(t),e)},C.forEachSeries=C.eachSeries=function(n,t,e){return C.eachOfSeries(n,y(t),e)},C.forEachLimit=C.eachLimit=function(n,t,e,r){return v(t)(n,y(e),r)},C.forEachOf=C.eachOf=function(t,e,r){function o(n){f--,n?r(n):null===c&&0>=f&&r(null)}r=i(r||n),t=t||[];for(var c,a=h(t),f=0;null!=(c=a());)f+=1,e(t[c],c,u(o));0===f&&r(null)},C.forEachOfSeries=C.eachOfSeries=function(t,e,r){function o(){var n=!0;return null===a?r(null):(e(t[a],a,u(function(t){if(t)r(t);else{if(a=c(),null===a)return r(null);n?C.setImmediate(o):o()}})),void(n=!1))}r=i(r||n),t=t||[];var c=h(t),a=c();o()},C.forEachOfLimit=C.eachOfLimit=function(n,t,e,r){v(t)(n,e,r)},C.map=d(b),C.mapSeries=k(b),C.mapLimit=g(b),C.inject=C.foldl=C.reduce=function(n,t,e,r){C.eachOfSeries(n,function(n,r,u){e(t,n,function(n,e){t=e,u(n)})},function(n){r(n,t)})},C.foldr=C.reduceRight=function(n,e,r,u){var i=a(n,t).reverse();C.reduce(i,e,r,u)},C.transform=function(n,t,e,r){3===arguments.length&&(r=e,e=t,t=M(n)?[]:{}),C.eachOf(n,function(n,r,u){e(t,n,r,u)},function(n){r(n,t)})},C.select=C.filter=d(w),C.selectLimit=C.filterLimit=g(w),C.selectSeries=C.filterSeries=k(w),C.reject=d(O),C.rejectLimit=g(O),C.rejectSeries=k(O),C.any=C.some=S(C.eachOf,e,t),C.someLimit=S(C.eachOfLimit,e,t),C.all=C.every=S(C.eachOf,r,r),C.everyLimit=S(C.eachOfLimit,r,r),C.detect=S(C.eachOf,t,E),C.detectSeries=S(C.eachOfSeries,t,E),C.detectLimit=S(C.eachOfLimit,t,E),C.sortBy=function(n,t,e){function r(n,t){var e=n.criteria,r=t.criteria;return r>e?-1:e>r?1:0}C.map(n,function(n,e){t(n,function(t,r){t?e(t):e(null,{value:n,criteria:r})})},function(n,t){return n?e(n):void e(null,a(t.sort(r),function(n){return n.value}))})},C.auto=function(t,e,r){function u(n){d.unshift(n)}function o(n){var t=p(d,n);t>=0&&d.splice(t,1)}function a(){h--,c(d.slice(0),function(n){n()})}r||(r=e,e=null),r=i(r||n);var f=W(t),h=f.length;if(!h)return r(null);e||(e=h);var y={},v=0,d=[];u(function(){h||r(null,y)}),c(f,function(n){function i(){return e>v&&l(g,function(n,t){return n&&y.hasOwnProperty(t)},!0)&&!y.hasOwnProperty(n)}function c(){i()&&(v++,o(c),h[h.length-1](d,y))}for(var f,h=M(t[n])?t[n]:[t[n]],d=m(function(t,e){if(v--,e.length<=1&&(e=e[0]),t){var u={};s(y,function(n,t){u[t]=n}),u[n]=e,r(t,u)}else y[n]=e,C.setImmediate(a)}),g=h.slice(0,h.length-1),k=g.length;k--;){if(!(f=t[g[k]]))throw new Error("Has inexistant dependency");if(M(f)&&p(f,n)>=0)throw new Error("Has cyclic dependencies")}i()?(v++,h[h.length-1](d,y)):u(c)})},C.retry=function(n,t,e){function r(n,t){if("number"==typeof t)n.times=parseInt(t,10)||i;else{if("object"!=typeof t)throw new Error("Unsupported argument type for 'times': "+typeof t);n.times=parseInt(t.times,10)||i,n.interval=parseInt(t.interval,10)||o}}function u(n,t){function e(n,e){return function(r){n(function(n,t){r(!n||e,{err:n,result:t})},t)}}function r(n){return function(t){setTimeout(function(){t(null)},n)}}for(;a.times;){var u=!(a.times-=1);c.push(e(a.task,u)),!u&&a.interval>0&&c.push(r(a.interval))}C.series(c,function(t,e){e=e[e.length-1],(n||a.callback)(e.err,e.result)})}var i=5,o=0,c=[],a={times:i,interval:o},f=arguments.length;if(1>f||f>3)throw new Error("Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)");return 2>=f&&"function"==typeof n&&(e=t,t=n),"function"!=typeof n&&r(a,n),a.callback=e,a.task=t,a.callback?u():u},C.waterfall=function(t,e){function r(n){return m(function(t,u){if(t)e.apply(null,[t].concat(u));else{var i=n.next();i?u.push(r(i)):u.push(e),z(n).apply(null,u)}})}if(e=i(e||n),!M(t)){var u=new Error("First argument to waterfall must be an array of functions");return e(u)}return t.length?void r(C.iterator(t))():e()},C.parallel=function(n,t){L(C.eachOf,n,t)},C.parallelLimit=function(n,t,e){L(v(t),n,e)},C.series=function(n,t){L(C.eachOfSeries,n,t)},C.iterator=function(n){function t(e){function r(){return n.length&&n[e].apply(null,arguments),r.next()}return r.next=function(){return e<n.length-1?t(e+1):null},r}return t(0)},C.apply=m(function(n,t){return m(function(e){return n.apply(null,t.concat(e))})}),C.concat=d(I),C.concatSeries=k(I),C.whilst=function(t,e,r){if(r=r||n,t()){var u=m(function(n,i){n?r(n):t.apply(this,i)?e(u):r(null)});e(u)}else r(null)},C.doWhilst=function(n,t,e){var r=0;return C.whilst(function(){return++r<=1||t.apply(this,arguments)},n,e)},C.until=function(n,t,e){return C.whilst(function(){return!n.apply(this,arguments)},t,e)},C.doUntil=function(n,t,e){return C.doWhilst(n,function(){return!t.apply(this,arguments)},e)},C.during=function(t,e,r){r=r||n;var u=m(function(n,e){n?r(n):(e.push(i),t.apply(this,e))}),i=function(n,t){n?r(n):t?e(u):r(null)};t(i)},C.doDuring=function(n,t,e){var r=0;C.during(function(n){r++<1?n(null,!0):t.apply(this,arguments)},n,e)},C.queue=function(n,t){var e=x(function(t,e){n(t[0],e)},t,1);return e},C.priorityQueue=function(t,e){function r(n,t){return n.priority-t.priority}function u(n,t,e){for(var r=-1,u=n.length-1;u>r;){var i=r+(u-r+1>>>1);e(t,n[i])>=0?r=i:u=i-1}return r}function i(t,e,i,o){if(null!=o&&"function"!=typeof o)throw new Error("task callback must be a function");return t.started=!0,M(e)||(e=[e]),0===e.length?C.setImmediate(function(){t.drain()}):void c(e,function(e){var c={data:e,priority:i,callback:"function"==typeof o?o:n};t.tasks.splice(u(t.tasks,c,r)+1,0,c),t.tasks.length===t.concurrency&&t.saturated(),C.setImmediate(t.process)})}var o=C.queue(t,e);return o.push=function(n,t,e){i(o,n,t,e)},delete o.unshift,o},C.cargo=function(n,t){return x(n,1,t)},C.log=j("log"),C.dir=j("dir"),C.memoize=function(n,e){var r={},u={};e=e||t;var i=m(function(t){var i=t.pop(),o=e.apply(null,t);o in r?C.setImmediate(function(){i.apply(null,r[o])}):o in u?u[o].push(i):(u[o]=[i],n.apply(null,t.concat([m(function(n){r[o]=n;var t=u[o];delete u[o];for(var e=0,i=t.length;i>e;e++)t[e].apply(null,n)})])))});return i.memo=r,i.unmemoized=n,i},C.unmemoize=function(n){return function(){return(n.unmemoized||n).apply(null,arguments)}},C.times=A(C.map),C.timesSeries=A(C.mapSeries),C.timesLimit=function(n,t,e,r){return C.mapLimit(f(n),t,e,r)},C.seq=function(){var t=arguments;return m(function(e){var r=this,u=e[e.length-1];"function"==typeof u?e.pop():u=n,C.reduce(t,e,function(n,t,e){t.apply(r,n.concat([m(function(n,t){e(n,t)})]))},function(n,t){u.apply(r,[n].concat(t))})})},C.compose=function(){return C.seq.apply(null,Array.prototype.reverse.call(arguments))},C.applyEach=T(C.eachOf),C.applyEachSeries=T(C.eachOfSeries),C.forever=function(t,e){function r(n){return n?i(n):void o(r)}var i=u(e||n),o=z(t);r()},C.ensureAsync=z,C.constant=m(function(n){var t=[null].concat(n);return function(n){return n.apply(this,t)}}),C.wrapSync=C.asyncify=function(n){return m(function(t){var e,r=t.pop();try{e=n.apply(this,t)}catch(u){return r(u)}U(e)&&"function"==typeof e.then?e.then(function(n){r(null,n)})["catch"](function(n){r(n.message?n:new Error(n))}):r(null,e)})},"object"==typeof module&&module.exports?module.exports=C:"function"==typeof define&&define.amd?define([],function(){return C}):P.async=C}();
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":11}],10:[function(require,module,exports){
exports.load=function(e,t){var n=new XMLHttpRequest;n.onreadystatechange=function(){if(4===n.readyState)if(n.status>=200&&n.status<300)t(null,n.responseText);else{var r=new Error("failed to request file '"+e+"'");r.errno=34,t(r)}};try{n.open("GET",e,!0),n.send(null)}catch(r){t(r)}};
},{}],11:[function(require,module,exports){
function cleanUpNextTick(){draining=!1,currentQueue.length?queue=currentQueue.concat(queue):queueIndex=-1,queue.length&&drainQueue()}function drainQueue(){if(!draining){var e=setTimeout(cleanUpNextTick);draining=!0;for(var n=queue.length;n;){for(currentQueue=queue,queue=[];++queueIndex<n;)currentQueue&&currentQueue[queueIndex].run();queueIndex=-1,n=queue.length}currentQueue=null,draining=!1,clearTimeout(e)}}function Item(e,n){this.fun=e,this.array=n}function noop(){}var process=module.exports={},queue=[],draining=!1,currentQueue,queueIndex=-1;process.nextTick=function(e){var n=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)n[r-1]=arguments[r];queue.push(new Item(e,n)),1!==queue.length||draining||setTimeout(drainQueue,0)},Item.prototype.run=function(){this.fun.apply(null,this.array)},process.title="browser",process.browser=!0,process.env={},process.argv=[],process.version="",process.versions={},process.on=noop,process.addListener=noop,process.once=noop,process.off=noop,process.removeListener=noop,process.removeAllListeners=noop,process.emit=noop,process.binding=function(e){throw new Error("process.binding is not supported")},process.cwd=function(){return"/"},process.chdir=function(e){throw new Error("process.chdir is not supported")},process.umask=function(){return 0};
},{}]},{},[1])(1)
});


//# sourceMappingURL=./weblas.map.json