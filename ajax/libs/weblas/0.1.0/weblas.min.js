!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).weblas=t()}}(function(){return function a(i,f,u){function s(r,t){if(!f[r]){if(!i[r]){var e="function"==typeof require&&require;if(!t&&e)return e(r,!0);if(l)return l(r,!0);var n=new Error("Cannot find module '"+r+"'");throw n.code="MODULE_NOT_FOUND",n}var o=f[r]={exports:{}};i[r][0].call(o.exports,function(t){var e=i[r][1][t];return s(e||t)},o,o.exports,a,i,f,u)}return f[r].exports}for(var l="function"==typeof require&&require,t=0;t<u.length;t++)s(u[t]);return s}({1:[function(t,e,r){var n=t("./lib/webgl"),o=t("./lib/gemmfloatcalculator");e.exports={WebGL:n,GEMMFloatCalculator:o}},{"./lib/gemmfloatcalculator":2,"./lib/webgl":3}],2:[function(t,e,r){function l(t){this.webgl=t,this.program=this.webgl.createProgram(l.FRAGMENT_SHADER)}(e.exports=l).FRAGMENT_SHADER="                                      \n// fragment shader that calculates the sum of the passed row and         \n// column (texture coord).                                               \n// we loop over the row and column and sum the product.                  \n// product is then rendered to 32-bit IEEE754 floating point in the      \n// output RGBA canvas.                                                   \n// readPixel is used to read the bytes.                                  \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n#ifdef GL_ES                                                                 \nprecision highp float;                                                   \n#endif                                                                       \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \nvarying vec2\t  vTex;         // row, column to calculate              \nuniform sampler2D usampler;\t\t// left in .r, right in .g               \nuniform int\t\t  uLength;      // interior (matching) dimension (r1/c2) \nuniform float\t  uStepS;       // increment across source texture       \nuniform float\t  uStepT;       // increment down source texture         \nuniform float\t  uOutRows;     // size of output in rows                \nuniform float\t  uOutCols;     // size of output in columns             \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n// sum row r x col c                                                     \nfloat sumrowcol(float row, float col) {                                  \n\tfloat sum = 0.;                // sum                                \n\tfloat ss = 0.5 * uStepS;       // column on source texture           \n\tfloat tt = 0.5 * uStepT;       // row on source texture              \n\tfloat r = (row + 0.5)*uStepT;  // moving texture coordinate          \n\tfloat c = (col + 0.5)*uStepS;  // moving texture coordinate          \n\tfor (int pos=0 ; pos<4096 ; ++pos) {                                 \n\t\tif(pos>=uLength) break;    // stop when we finish the row/column \n\t\tfloat m1 = texture2D(usampler,vec2(ss,r)).r;                     \n\t\tfloat m2 = texture2D(usampler,vec2(c,tt)).g;                     \n\t\tsum += (m1*m2);                                                  \n\t\tss += uStepS;                                                    \n\t\ttt += uStepT;                                                    \n\t}                                                                    \n\treturn sum;                                                          \n}                                                                        \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \nvoid main(void) {                                                        \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n\t // get the implied row and column from .s and .t of passed texel    \n\tfloat col = floor((vTex.s*uOutRows));                                \n\tfloat row = floor((vTex.t*uOutCols));                                \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n\t// sum row x col for the passed pixel                                \n\tfloat v = sumrowcol(row,col);                                        \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n\t// Render to IEEE 754 Floating Point                                 \n\tif (v==0.) {                                                         \n\t\tgl_FragColor = vec4(0.,0.,0.,0.);                                \n\t\treturn;                                                          \n\t}                                                                    \n\t// TODO: correctly handle denormal numbers                           \n\t// http://www.2ality.com/2012/04/number-encoding.html                \n\tfloat a = abs(v);                           // encode absolute value + sign \n\tfloat exp = floor(log2(a));                 // number of powers of 2 \n\tfloat mant = (a * pow(2.,23.-exp));         // multiply to fill 24 bits (implied leading 1) \n\tfloat mant1 = floor(mant / 256. / 256.);    // first 8 bits of mantissa \n\tfloat mant2 = mod(floor(mant / 256.),256.); // second 8 bits         \n\tfloat mant3 = mod(mant,256.);               // third 8 bits          \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n\thighp float sign = 128.-128.*(a/v);\t\t\t// sign bit is 256 or 0  \n\thighp float e = (sign+exp+127.)/510.;\t\t// exponent and sign     \n\thighp float m1 = (mant1-(128.*(1.-mod(exp+127.,2.))))/255.; // handle leading bit \n\thighp float m2 = (mant2)/255.;\t\t\t\t// middle part           \n\thighp float m3 = (mant3+.5)/255.;\t\t\t// scale to 0 - 255      \n\tgl_FragColor = vec4(m3,m2,m1,e);\t\t\t// output an IEEE754 32-bit floating point number \n}                                                                        \n",l.packData=function(t,e,r,n,o,a){var i=e,f=r,u=o,s=a,l=Math.max(i,u),c=Math.max(f,s),m=l*c,E=new Float32Array(3*m),h=0,d=0,p=0;if(i===u&&f===s)for(;E[h++]=t[d++],E[h++]=n[p++],h++,--m;);else for(var T=0,R=0,x=0;T=(x=h/3|0)/c|0,(R=x%c)<f&&T<i&&(E[h]=t[d++]),h++,R<s&&T<u&&(E[h]=n[p++]),h+=2,--m;);return E},l.prototype.setupInputTexture=function(t,e,r,n,o,a){var i,f,u,s=this.webgl.context;i=l.packData(t,e,r,n,o,a),f=Math.max(r,a),u=Math.max(e,o),this.webgl.canvas.height=u,this.webgl.canvas.width=f,s.viewport(0,0,f,u);this.bindData(i,f,u)},l.TEXTURE_UNIFORM_NAME="usampler",l.prototype.bindData=function(t,e,r){var n=this.webgl.context,o=this.program,a=n.createTexture();n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_2D,a),n.texImage2D(n.TEXTURE_2D,0,n.RGB,e,r,0,n.RGB,n.FLOAT,t),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.NEAREST);var i=n.getUniformLocation(o,l.TEXTURE_UNIFORM_NAME);return n.uniform1i(i,0),a},l.prototype.bindFramebuffer=function(t,e,r){var n=this.webgl.context;return this.renderbuffer=this.renderbuffer||n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,null),n.bindRenderbuffer(n.RENDERBUFFER,this.renderbuffer),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,r,e),this.framebuffer=this.framebuffer||n.createFramebuffer(),n.bindFramebuffer(n.FRAMEBUFFER,this.framebuffer),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,this.renderbuffer),this.framebuffer},l.prototype.calculate=function(t,e,r,n,o,a,i,f,u){var s,l,c=this.webgl.context;if(c.useProgram(this.program),this.setupInputTexture(i,t,e,f,r,n),this.bindUniforms(t,e,r,n),this.bindVertices(),s=this.webgl.createDestinationTexture(),this.bindFramebuffer(s,t,n),c.checkFramebufferStatus(c.FRAMEBUFFER)!=c.FRAMEBUFFER_COMPLETE)throw new Error("Bound framebuffer is not complete.");return c.drawElements(c.TRIANGLES,6,c.UNSIGNED_SHORT,0),l=new ArrayBuffer(t*n*Float32Array.BYTES_PER_ELEMENT),prod=new Uint8Array(l),c.readPixels(0,0,n,t,c.RGBA,c.UNSIGNED_BYTE,prod),new Float32Array(l)},l.prototype.bindUniforms=function(t,e,r,n){var o=this.webgl.context,a=this.program,i=o.getUniformLocation(a,"uLength"),f=o.getUniformLocation(a,"uOutRows"),u=o.getUniformLocation(a,"uOutCols"),s=o.getUniformLocation(a,"uStepS"),l=o.getUniformLocation(a,"uStepT");o.uniform1i(i,e),o.uniform1f(f,t),o.uniform1f(u,n),o.uniform1f(s,1/Math.max(e,n)),o.uniform1f(l,1/Math.max(t,r))},l.prototype.bindVertices=function(){var t=this.webgl.context,e=this.program,r=t.getAttribLocation(e,"aPos"),n=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,n);t.bufferData(t.ARRAY_BUFFER,new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,1,0]),t.STATIC_DRAW),t.vertexAttribPointer(r,3,t.FLOAT,!1,0,0),t.enableVertexAttribArray(r);var o=t.getAttribLocation(e,"aTex"),a=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,a);t.bufferData(t.ARRAY_BUFFER,new Float32Array([0,0,1,0,1,1,0,1]),t.STATIC_DRAW),t.vertexAttribPointer(o,2,t.FLOAT,!1,0,0),t.enableVertexAttribArray(o);var i=t.createBuffer();t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,i);t.bufferData(t.ELEMENT_ARRAY_BUFFER,new Uint16Array([0,1,2,0,2,3]),t.STATIC_DRAW)}},{}],3:[function(t,e,r){function n(t){var e,r;if(void 0===(t=t||{}).canvas?this.canvas=document.createElement("canvas"):this.canvas=t.canvas,e={premultipliedAlpha:!1,preserveDrawingBuffer:!1},this.context=this.canvas.getContext("experimental-webgl",e),void 0===this.context)throw new Error("No support for Webgl.");try{r=this.context.getExtension("OES_texture_float")}catch(t){}r?this.hasFloat=!0:(console.log("No support for OES_texture_float extension."),this.hasFloat=!1),this.vertexShader=this.context.createShader(this.context.VERTEX_SHADER),this.context.shaderSource(this.vertexShader,n.PASS_THROUGH_VERTEX_SHADER),this.context.compileShader(this.vertexShader)}(e.exports=n).PASS_THROUGH_VERTEX_SHADER="// vertex shader for a single quad                                           \n// work is performed based on the texels being passed through                \n// the operation specific texture shader.                                    \n#ifdef GL_ES                                                                 \nprecision highp float;                                                       \n#endif                                                                       \nattribute vec3 aPos;                                                         \nattribute vec2 aTex;                                                         \nvarying vec2   vTex;                                                         \nvoid main(void)                                                              \n{                                                                            \n\t// just pass the position and texture coords                             \n\tgl_Position = vec4(aPos, 1.0);                                           \n\tvTex = aTex;                                                             \n}                                                                            \n",n.prototype.createProgram=function(t){var e,r=this.context;if(e=r.createShader(r.FRAGMENT_SHADER),r.shaderSource(e,t),r.compileShader(e),0==r.getShaderParameter(e,r.COMPILE_STATUS))throw new Error(r.getShaderInfoLog(e));var n=r.createProgram();return r.attachShader(n,this.vertexShader),r.attachShader(n,e),r.linkProgram(n),n},n.prototype.createDestinationTexture=function(){var t=this.context,e=t.createTexture();return t.activeTexture(t.TEXTURE2),t.bindTexture(t.TEXTURE_2D,e),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,this.canvas),e}},{}]},{},[1])(1)});